{"diagram":{"image":{"height":200,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","width":200,"y":0,"x":0},"elements":{"id":"root","structure":"mind_free","leftChildren":[{"id":"8675111a3318","title":"面向对象","children":[{"id":"93e88422321d","title":"封装","parent":"8675111a3318","children":[{"id":"579c5cd07e81","title":"访问控制符","parent":"93e88422321d","children":[{"id":"1573a7077c75","tags":[],"title":"private","parent":"579c5cd07e81","children":[],"note":"权限范围：当前类\n权限说明：只有在当前类的内部能够访问"},{"id":"b68aa9757cc1","title":"default","parent":"579c5cd07e81","children":[],"note":"权限范围：package\n权限说明：相同包下的类可以访问"},{"id":"198bd7e851de","title":"protected","parent":"579c5cd07e81","children":[],"note":"权限范围：package和子类\n权限说明：相同包下的类及其子类可以访问"},{"id":"558478b5f45a","title":"public","parent":"579c5cd07e81","children":[],"note":"权限范围：公共访问权限\n权限说明：能够被所有类访问"}],"note":"访问控制符用于控制一个类的成员是否可以被其他类访问。\n- 局部变量的作用域是其所在的方法，不可能被其他类访问，因此不能使用访问控制符修饰\n- 外部类只能使用public/default\n"},{"id":"27ef0e8fc9c6","title":"package","parent":"93e88422321d","children":[],"note":"package 是为了区分同名的类，因此使用类时总是需要使用类全名(package+className)\nimport 导入包，是为了简化包名\nimport static 导入类，是为了简化类名"}],"note":"封装[Encapsulation]: 隐藏对象的实现细节,通过公用方法暴露该对象的功能"},{"id":"9f4b313afe30","title":"继承","children":[{"id":"1b87eeb7212e","title":"单继承","children":[],"parent":"9f4b313afe30","note":"每个类只能有一个直接父类，可以有多个间接父类，Object是所有类的直接/间接父类"},{"id":"739a5d0254fd","title":"方法重写","children":[],"parent":"9f4b313afe30","note":"定义：子类包含与父类同名的方法，也称方法覆盖\n\n方法重写的规则\n- 方法名相同\n- 形参列表相同\n- 子类方法的返回值类型小于等于父类方法\n- 子类方法的异常声明小于等于父类方法\n- 子类方法的访问权限大于等于父类方法\n- 子类方法和父类方法必须同为类/实例方法\n\n调用被覆盖的父类方法\n- super调用父类实例方法\n- 父类名称调用父类类方法\n\n父类private方法对子类是隐藏的，子类无法访问，也就无法重写"}],"parent":"8675111a3318","note":"继承[Inheritance]: 实现软件复用的重要手段,子类可以获得父类的属性和方法"},{"id":"484ce132ca7d","title":"多态","children":[{"id":"378d8c64be74","title":"编译时类型","children":[],"parent":"484ce132ca7d","note":"定义：声明变量时使用的数据类型"},{"id":"e1d22fb91488","title":"运行时类型","children":[],"parent":"484ce132ca7d","note":"定义：实际赋值给该变量的数据类型"}],"parent":"8675111a3318","note":"定义：编译时类型和运行时类型不一致时即出现多态.\n- 相同类型的变量，调用同一个方法时呈现不同子类的行为特征，即为多态\n\n- 引用变量在编译阶段只能调用其编译时类型所具有的方法，但在运行时则执行运行时类型所具有的方法。\n- 引用变量总是试图访问其编译时类型所定义的成员变量，而不是运行时类型所定义的变量。"},{"id":"6159bd0f721d","title":"分支主题","children":[{"id":"9343c67600ed","title":"包装类","children":[{"id":"89ba4885651f","title":"自动拆箱/装箱","children":[],"parent":"9343c67600ed","note":"自动拆箱：直接把包装类对象赋值给对应的基本类型变量\n自动装箱：把一个基本类型变量直接赋值给对应的包装类变量或者Object变量"},{"id":"9a67cf27ea6a","title":"基本类型和字符串类型转换","children":[],"parent":"9343c67600ed","note":"字符串-&gt;基本类型\n- Integer.parseInt(intStr)\n- new Integer(intStr)\n\n基本类型-&gt;字符串\n- String.valueOf(2.345f)\n- 5+&quot;&quot;\n"},{"id":"32b1a489c226","title":"包装类的缓存设计","children":[],"parent":"9343c67600ed","note":"Integer类会缓存-128-127之间的整数\n```\nInteger a=2;\nInteger b=2;\na==b // true\n\nInteger a=128;\nInteger b=128;\na==b //false\n\nnew Integer(2)==new Integer(2) // false\n"}],"parent":"6159bd0f721d","note":"作用：解决基本类型不能作为Object类型变量使用的问题\n\n定义：8种基本类型分别对应的引用类型称为包装类"},{"id":"ceb48216595c","title":"final","children":[{"id":"4ec40a501fb7","title":"final变量","children":[{"id":"9c64bc800874","title":"分类","children":[{"id":"14ea4cfaac5e","title":"final成员变量","children":[],"parent":"9c64bc800874","note":"系统会对成员变量进行默认初始化，因此Java规定final成员变量必须由程序员在合适的时机显式的指定初始值\n- 类变量必须在静态初始化块或声明时指定初始值\n- 实例变量必须在静态初始化块、构造器或声明时指定初始值"},{"id":"addcfe9b405b","title":"final局部变量<br>","children":[],"parent":"9c64bc800874","note":"系统不会对局部变量进行默认初始化，因此final局部变量可以直到使用时才进行初始化"}],"parent":"4ec40a501fb7","note":"无法重复赋值"},{"id":"9741752cde4a","title":"宏替换","children":[],"parent":"4ec40a501fb7","note":"“宏变量&quot;定义：满足以下条件的final变量，相当于直接量\n- final修饰\n- 定义final变量时指定了初始值\n- 该初始值可以在编译时确定\n\n编译器会将程序中所有用到”宏变量“的地方替换成该变量的值"}],"parent":"ceb48216595c"},{"id":"ee6d787df426","title":"final方法","children":[{"id":"edfa73cb67c4","title":"无法被重写，可以被重载","children":[],"parent":"ee6d787df426"}],"parent":"ceb48216595c"},{"id":"b885a17da740","title":"final类","children":[{"id":"c11ec341589e","title":"无法被继承","children":[],"parent":"b885a17da740"}],"parent":"ceb48216595c"}],"parent":"6159bd0f721d"},{"id":"ae4a5de55e89","title":"接口和抽象类","children":[{"id":"4d5dace1049b","title":"抽象类","children":[],"parent":"ae4a5de55e89","note":"有抽象方法的类只能被定义成抽象类，抽象类里可以没有抽象方法\n- 抽象类和抽象方法都必须使用abstract修饰，抽象方法不能有方法体\n- 抽象类不能被实例化，构造器主要用于被子类调用\n\n抽象类只能被继承，抽象方法必须被重写\n\n- abstract和final永远不能同时使用\n- abstract和static不能同时修饰方法\n- abstract和private不能同时修饰方法"},{"id":"e30ba75b7b06","title":"接口","children":[],"parent":"ae4a5de55e89","note":"```\n[修饰符] interface 接口名 extends 父接口1,父接口2...\n{\n    常量(类变量)定义...\n    抽象方法定义...\n    内部类/接口/枚举定义...\n    默认方法/类方法定义...\n}\n```"}],"parent":"6159bd0f721d","note":"相同点\n- 接口和抽象类都不能被实例化，只能被实现/继承\n- 接口和抽象类都包含抽象方法，实现类/子类必须实现这些抽象方法\n\n不同点\n- 接口体现的是规范。规定了接口实现者必须向外提供的服务，规定了接口调用者可以调用的服务以及如何调用这些服务\n- 抽象类体现的是模板设计。抽象类实现了部分通用功能，并将剩下的功能交由子类实现。\n\n语法区别\n- 接口只能包含抽象方法和默认方法，不能为普通方法提供实现；抽象类则完全可以包含普通方法\n- 接口不能定义类方法；抽象类可以\n- 接口只能定义静态常量，不能定义普通成员变量；抽象类都可以\n- 接口不包含构造器；抽象类包含构造器，用于被子类调用\n- 接口不包含初始化块；抽象类包含\n- 一个类只能有一个直接父类，包括抽象类，但可以实现多个接口"},{"id":"532f0a429196","title":"特殊类","children":[{"id":"2fce27ba9dc5","title":"单例类","children":[],"parent":"532f0a429196","note":"- 隐藏构造器\n- 提供公用类方法以便获取类的实例\n- 使用类变量缓存已创建的实例，保证该类只有一个实例"},{"id":"71c2b836a5e3","title":"不可变类","children":[],"parent":"532f0a429196","note":"定义：创建该类实例后，该实例的实例变量是不可改变的\n\nEg：8个包装类和String类都是不可变类\n\n不可变类规则\n- private final 成员变量\n- 提供带参构造器，以便初始化成员变量\n- 仅为成员变量提供getter方法\n- (可选)重写hashCode()和equals()。\n    - equals根据关键成员变量来作为对象相等的标准\n    - 保证equals相等的对象hashcode也相等"},{"id":"1ddddac1b6ee","title":"缓存实例的不可变类","children":[],"parent":"532f0a429196","note":"使用数组缓存不可变类的多个实例"}],"parent":"6159bd0f721d"},{"id":"04cba614e1e3","title":"设计模式","children":[{"id":"a95ee00ae73d","title":"模板模式","children":[],"parent":"04cba614e1e3","note":"抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上保留抽象类的行为方式\n\n模板模式：抽象父类提供了多个子类的通用方法，并把一个或多个方法留给其子类实现\n\n模板模式简单规则\n- 抽象父类实现通用方法，定义抽象方法，将不能实现的抽象方法留给子类实现\n- 父类中可能包含需要调用其他方法的方法，这些被调方法可以由父类或子类实现。父类仅仅定义了通用算法，算法的具体实现依赖子类"},{"id":"6d6d77e8aaa4","title":"简单工厂模式","children":[],"parent":"04cba614e1e3"},{"id":"eeee79d6e530","title":"命令模式","children":[],"parent":"04cba614e1e3"}],"parent":"6159bd0f721d"}],"parent":"8675111a3318"},{"id":"69fe2324ff99","title":"类和对象","children":[{"id":"ca32dc1b6fe6","title":"成员分类","parent":"69fe2324ff99","children":[{"id":"1e67f3b2e4b2","title":"变量","children":[{"id":"7440df7bcabe","title":"局部变量","parent":"1e67f3b2e4b2","children":[{"id":"3d5b31dfda80","title":"形参变量","parent":"7440df7bcabe","children":[]},{"id":"cf50c5da42f2","title":"方法局部变量","parent":"7440df7bcabe","children":[]},{"id":"35e2c79b873a","title":"代码块局部变量","parent":"7440df7bcabe","children":[]}]},{"id":"59adf14fa715","title":"成员变量","parent":"1e67f3b2e4b2","children":[{"id":"163abcdf60a8","title":"类变量","parent":"59adf14fa715","children":[]},{"id":"37e6756427bc","title":"实例变量","parent":"59adf14fa715","children":[]}],"note":"定义该类或其实例的状态数据\n"}],"parent":"ca32dc1b6fe6","note":"变量\n- 程序的本质是对内存中数据的访问和修改\n- 每种编程语言都提供了访问内存的机制，这种机制就是**变量**\n- 程序中的每个变量代表了一小块内存，对变量进行赋值、修改等操作就是对内存中的数据进行操作"},{"id":"14cb14b0ba95","title":"方法","parent":"ca32dc1b6fe6","children":[{"id":"8f5304796e06","title":"类方法","parent":"14cb14b0ba95","children":[]},{"id":"5ce6eeae3371","title":"实例方法","parent":"14cb14b0ba95","children":[]}],"note":"该类或其实例的行为特征、功能实现\n\n方法重载\n- 定义：同一个类中包含两个或以上的同名方法\n- 确定一个方法的三要素\n    - 调用者\n    - 方法名\n    - 形参列表\n- 方法的返回值类型和修饰符与方法重载没有任何关系"},{"id":"ff41ef36b316","title":"构造器","parent":"ca32dc1b6fe6","children":[],"note":"构造器作用：在创建实例时执行显式初始化并返回该实例的引用\n\nJava类必须包含一个或以上的构造器\n- 程序员若没有提供构造器，则系统会为其提供一个默认的无参构造器\n- 程序员一旦提供了构造器，则系统不再提供默认的无参构造器\n\n实例的创建过程\n1. 系统在执行构造器的执行体之前，已经分配内存空间，创建并初始化该实例，但此时该实例无法被访问\n2. 构造器执行体执行自定义的初始化后将实例的引用赋值给实例变量，此时程序才能通过实例变量访问到该实例。\n\n"},{"id":"92dcec3bb8e1","title":"初始化块","parent":"ca32dc1b6fe6","children":[{"id":"516375d2f5bc","title":"类初始化块","parent":"92dcec3bb8e1","children":[]},{"id":"1b5a01e4fff9","title":"实例初始化块","parent":"92dcec3bb8e1","children":[]}]},{"id":"2ce38fa2a1e9","title":"内部类/接口/枚举","parent":"ca32dc1b6fe6","children":[]}]},{"id":"c1fd3d5901ec","title":"类成员","children":[{"id":"ab128c7b4329","title":"类变量","children":[],"parent":"c1fd3d5901ec","note":"初始化时机：系统第一次使用该类时，系统会为类变量分配内存空间，类变量开始生效直到类被卸载，其占用的内存才会被系统的垃圾回收机制回收"},{"id":"17e84e3ab196","title":"类方法","children":[],"parent":"c1fd3d5901ec"},{"id":"4e500ac23894","title":"类初始化块","children":[],"parent":"c1fd3d5901ec","note":"初始化时机：在类的初始化阶段被执行，一旦类初始化完成后，类初始化块将永远不再被执行"},{"id":"cf5ac742cc3b","title":"类内部类/接口/枚举","children":[],"parent":"c1fd3d5901ec"}],"parent":"69fe2324ff99"}],"parent":"8675111a3318","note":"类是对一类具有相同/相似性质的事物的抽象，对象是该类事物实际存在的个体\n\n对象的抽象化是类，类的具体化是对象。"}],"parent":"root"}],"title":"JavaSE","root":true,"theme":"paper","children":[{"id":"bf67e199201c","title":"语法基础","children":[{"id":"d94efd5e8c01","title":"Java程序运行机制","children":[],"parent":"bf67e199201c","note":"Java程序运行机制：先编译，后解释,兼具解释型语言和编译型语言的特征"},{"id":"d58f5aa851dc","title":"注释","parent":"bf67e199201c","children":[{"id":"4710c2d15a67","title":"单行注释","children":[],"parent":"d58f5aa851dc"},{"id":"70c754b64dca","title":"多行注释","children":[],"parent":"d58f5aa851dc"},{"id":"b8709575bd1e","title":"文档注释","children":[],"parent":"d58f5aa851dc"}]},{"id":"a596782cd8b9","title":"标识符和关键字","parent":"bf67e199201c","children":[{"id":"911f07959f0e","title":"标识符","children":[],"parent":"a596782cd8b9","note":"定义：给程序中变量、类、方法命名的符号"},{"id":"fb8fba717712","title":"关键字","children":[],"parent":"a596782cd8b9","note":"定义：Java中具有特殊用途的单词称为关键字，都是小写的"},{"id":"8b460fb47cfc","title":"保留字","children":[],"parent":"a596782cd8b9","note":"定义：Java 目前尚不支持，但未来可能使用 的关键字(goto/const)"},{"id":"e1a6f7699b03","title":"直接量","parent":"a596782cd8b9","children":[],"note":"不能用作标识符的特殊值(true,false,null)"}]},{"id":"9d77a033d4b1","title":"数据类型","children":[{"id":"ec91ad759a56","title":"基本类型","parent":"9d77a033d4b1","children":[{"id":"847f6231cbd8","title":"布尔类型","parent":"ec91ad759a56","children":[{"id":"dbc70c689660","title":"boolean(1字节)","parent":"847f6231cbd8","children":[]}]},{"id":"55c04033044d","title":"字符类型","parent":"ec91ad759a56","children":[{"id":"7aa0c04b7066","title":"char(2字节)","parent":"55c04033044d","children":[]}],"note":""},{"id":"a9b0e17a4a68","title":"数值类型","parent":"ec91ad759a56","children":[{"id":"727e962738d0","title":"整数类型","parent":"a9b0e17a4a68","children":[{"id":"2ff45f95520f","title":"byte(1字节)","parent":"727e962738d0","children":[]},{"id":"eb0c304c56ce","title":"short(2字节)","parent":"727e962738d0","children":[]},{"id":"054415e01b0d","title":"int(4字节)","parent":"727e962738d0","children":[]},{"id":"0a7cc5451b99","title":"long(8字节)","parent":"727e962738d0","children":[]}],"note":"整型数值表示形式\n- 二进制(0b/0B开头)\n- 八进制(0开头)\n- 十进制(默认)\n- 十六进制(0x或0X开头[10-15用a~f表示，不区分大小写])"},{"id":"203cfb94bcf9","title":"浮点类型","parent":"a9b0e17a4a68","children":[{"id":"ff09781ea215","title":"float(4字节)","parent":"203cfb94bcf9","children":[]},{"id":"c6a473c0fc8b","title":"double(8字节)","parent":"203cfb94bcf9","children":[]}],"note":""}]}]},{"id":"02ce5946964f","title":"引用类型","parent":"9d77a033d4b1","children":[{"id":"3f1b50833f76","title":"类","parent":"02ce5946964f","children":[]},{"id":"5dd91c241364","title":"接口","parent":"02ce5946964f","children":[]},{"id":"a65a5fec52a2","title":"数组","parent":"02ce5946964f","children":[]},{"id":"9327711b396f","title":"null","parent":"02ce5946964f","children":[]},{"id":"0f9e82f0d832","title":"String","parent":"02ce5946964f","children":[]}]}],"parent":"bf67e199201c","note":"变量的类型"},{"id":"b3abb529c43b","title":"类型转换","children":[{"id":"9b6831d8c180","title":"基本类型的类型转换","parent":"b3abb529c43b","children":[{"id":"8792938a5e26","title":"自动类型转换","parent":"9b6831d8c180","children":[],"note":""},{"id":"29cc2d36310c","title":"强制类型转换","children":[],"parent":"9b6831d8c180"}]},{"id":"76f8d3f13a16","title":"引用变量的类型转换","children":[{"id":"15ca64c62fa5","title":"自动向上转型(子类赋值给父类)","parent":"76f8d3f13a16","children":[]},{"id":"64999689e237","title":"强制类型转换","children":[],"parent":"76f8d3f13a16"}],"parent":"b3abb529c43b"},{"id":"3313535e19a9","title":"表达式类型自动提升","children":[],"parent":"b3abb529c43b"}],"parent":"bf67e199201c"},{"id":"9d1f2bd54f04","title":"运算符","children":[{"id":"a89088725a98","title":"算术运算符","children":[],"parent":"9d1f2bd54f04"},{"id":"b986eceeef69","title":"赋值运算符","children":[],"parent":"9d1f2bd54f04"},{"id":"8fd27c30f19a","title":"位运算符","children":[],"parent":"9d1f2bd54f04"},{"id":"76586ebec936","title":"逻辑运算符","children":[],"parent":"9d1f2bd54f04"},{"id":"9af52c316f15","title":"三目运算符","children":[],"parent":"9d1f2bd54f04"},{"id":"c4c2bd25de14","title":"比较运算符","children":[{"id":"95cf27e131ed","title":"==","children":[],"parent":"c4c2bd25de14","note":"- 操作数都是数值类型，即使数据类型不同，只要值相等就返回true\n- 操作数都是引用类型，仅当两个变量类型具有父子关系时才可以比较，仅当两个变量指向同一个对象时才返回true"},{"id":"e50711a8c2d7","title":"equals","children":[],"parent":"c4c2bd25de14","note":"操作数必须是引用类型，equals()方法自定义了对象相等的标准"}],"parent":"9d1f2bd54f04"},{"id":"f2d9c4053c91","title":"类型相关运算符","children":[],"parent":"9d1f2bd54f04"}],"parent":"bf67e199201c"},{"id":"e083bb70e3f5","title":"流程控制和数组","children":[],"parent":"bf67e199201c"}],"parent":"root"},{"id":"41349d8119dc","title":"垃圾回收机制","children":[],"parent":"root","note":"定义：JRE提供一个后台线程，在CPU空闲或者内存不足时，回收那些不再使用的内存，这种机制称为垃圾回收机制"}]}},"meta":{"id":"5ce8f281e4b078e7ea8d4369","member":"5939dfcce4b05a4d43807135","exportTime":"2019-06-04 05:14:24","diagramInfo":{"category":"mind_free","title":"JavaSE知识图谱","created":"2019-05-25 15:45:05","creator":"5939dfcce4b05a4d43807135","modified":"2019-05-25 15:45:05"},"type":"ProcessOn Schema File","version":"1.0"}}