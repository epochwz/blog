Annotation[注解/元数据]：代码里的特殊标记，被用来为程序元素设置元数据，可以在编译、类加载、运行时被APT[注解处理工具]读取，并执行相应的处理。

Annotation类似修饰符，可以修饰程序元素[包/类/构造器/方法/成员变量/参数/具备变量]的声明，这些修饰信息被存储在 Annotation 的键值对中。

Annotation是一个接口，程序可以通过反射来获取指定程序元素的 Annotation 对象，然后通过该对象来取得注解里的元数据。

通过使用注解，开发人员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。APT[代码分析工具、开发工具和部署工具]可以通过这些补充信息进行验证或者进行部署。

增加/删除Annotation都不影响程序代码的执行，只有使用APT对 Annotation 中的信息进行访问并处理，Annotation 才能在运行时起作用

## java.lang包下的五个基本Annotation
1. @Override：只能修饰方法，指定方法覆载，强制被修饰的方法必须重写父类的方法
    - 该注解使编译器检查这个方法，保证父类包含一个被该方法重写的方法，否则编译出错。
    - 避免方法签名拼写错误等低级错误
2. @Deprecated：用于标示某个程序元素[类/方法/接口]已过时，当其他程序使用已过时的类、方法时，编译器发出警告。与文档注释中的@Deprecated 作用基本相同。   
3. @SuppressWarnings:抑制编译器警告,被修饰的程序元素[以及该元素中的所有子元素]取消显示指定的编译器警告。
    - 使用该注解时一定要在括号中使用name=value的形式为该注解的成员变量设置值
4. @SafeVarargs:专门用于抑制"堆污染"警告
    - 堆污染:把一个不带泛型的对象赋给一个带泛型的变量时往往会发生堆污染。对于形参个数可变且形参类型是泛型的方法，更容易导致"堆污染"
    - @SuppressWarnings("unchecked")修饰也能达到抑制目的
    - 编译时使用-Xlint:varargs选项也可抑制"堆污染"警告
    ```java
    import java.util.*;
    
    // @SuppressWarnings(value="unchecked")
    public class Test{
        // @SafeVarargs
        public static void info(List<String>... listStrArray){
            // Java语言不允许创建泛型数组，因此listArray只能被当成List[]处理
            // 此时相当于把List<String>赋给了List，已经发生了泛型“擦除”，发生了堆污染
            // 编译器警告:Test.java使用了未经检查或不安全的操作。
            List[] listArray = listStrArray;
        }
    
        public static void main(String[] args){
            Test.info(Arrays.asList("Hello!"), Arrays.asList("World!"));
        }
    }
    ```
5. @FunctionalInterface：只能修饰接口，用来指定某个接口必须是函数式接口
    - 使编译器检查被修饰的接口，保证该接口只包含一个抽象方法，否则编译出错
    - 避免低级错误[定义多个抽象方法]
    - 函数式接口:接口中只有一个抽象方法[可以包含多个默认方法或类方法]:为 Lambda 而生，允许使用 Lambda 表达式创建函数式接口的实例。

 
