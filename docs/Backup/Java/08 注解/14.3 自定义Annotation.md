## 14.3.1 定义 Annotation
定义Annotation:`@interface AnnotationName{}`
- 类似自定义一个接口，该Annotation"接口"继承了java.lang.annotation.Annotation[所有Annotation的父接口，代表程序元素前面的注解]，并拥有Annotation接口的方法
- 自定义的Annotation默认可以修饰任何程序元素

Annotation分类:
- 标记Annotation:没有成员变量，仅利用自身的存在与否来提供信息:`@interface AnnoTest{}`
- 元数据Annotation:包含成员变量，可以接受更多的元数据。
    ```java
    @interface AnnoTest{
        // 以无形参的方法来定义 Annotation的成员变量：返回值即成员变量的类型，方法名即成员变量名
        String name();
        // 一旦定义了成员变量，则使用该注解时应该为其成员变量指定值[除非定义注解时指定默认值]
        int age() default 32;
    }
    public class Test{
        // name没有默认值，必须指定值，而age有默认值，可以省略[若覆盖默认值，则默认值失效]
        @AnnotationTest(name="成员变量name的值")
        public void info(){}
    }
    ```

## 14.3.2 提取 Annotation 信息
使用 Annotation 修饰了程序元素后，这些 Annotation 并不会自己生效，必须由开发者提供相应的工具来提取并处理 Annotation 信息

java.lang.reflect包含了一些实现反射功能的工具类,支持读取 运行时Annotation 的功能只有当定义Annotation时使用了`@Retention(RetentionPolicy.RUNTIME)`修饰，该Annotation 才会在运行时可见，JVM 才会在装载*.class文件时读取其中的 Annotation

java.lang.reflect.AnnotatedElement接口是所有程序元素的父接口,代表程序中可以接受注解的程序元素。所以程序通过反射获取某个类的 AnnotatedElement 对象后，可以使用该对象的方法来访问 Annotation 信息

AnnotatedElement接口的实现类:
1. 类定义Class
2. 构造器定义Constructor
3. 成员变量定义Field
4. 方法定义Method 
5. 包定义Package

获取某个类某个方法所有注解的代码:`Annotation[] annos=Class.forName(String className).getMethod(String methodName).getAnnotations();`

获取某个对象某个方法所有注解的代码:`Annotation[] annos=obj.getClass().getMethod(String methodName).getAnnotations();`

获取某个注解的元数据:将注解强制转换成所需的注解类型，通过注解对象的抽象方法来访问这些元数据`((AnnoTest)annos[i]).name();`

## 14.3.3 Java8 新增的重复注解
Java8 以前，同一个程序元素最多只能使用一个相同类型的 Annotation，若需要使用多个，则必须使用 Annotation 容器。
```java
// @Result实际上是"容器"注解@Results的成员变量Result[] value的数组元素
@Results(
    {
        @Result(name="failure",location="failed.jsp"),
        @Result(name="success",location="succ.jsp")
    }
)
public Action resultAction{}
```
Java8 以后，可直接使用多个相同类型的注解，开发重复注解需要使用 @Repeatable 修饰。
```java
@Result(name="failure",location="failed.jsp")
@Result(name="success",location="succ.jsp")
public Action resultAction{}
```

示例：
```java
package jwz;

import java.lang.annotation.*;

/**
 * 容器注解类:可包含多个希望被重复使用的注解
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@interface FkTags{
    // 定义value成员变量，该成员变量可接受多个@FkTag注解
    FkTag[] value();
}

/**
 * 可重复注解类
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
// 指定该注解为可重复注解
// 必须为@Repeatable 的成员变量指定值[该值应该是个"容器"注解]
@Repeatable(FkTags.class) 
@interface FkTag{
    // 为该注解定义2个成员变量
    String name() default "大傻逼";
    int age();
}

/**
 * 测试：可重复注解
 */
@FkTag(age=5)
@FkTag(name="疯狂Java" , age=9)
public class FkTagTest{
    public static void main(String[] args){
        Class<FkTagTest> clazz = FkTagTest.class;
        // 使用Java 8新增的getDeclaredAnnotationsByType()方法获取 修饰FkTagTest类的多个@FkTag注解 
        FkTag[] tags = clazz.getDeclaredAnnotationsByType(FkTag.class);

        // 遍历 修饰FkTagTest类的多个@FkTag注解
        for(FkTag tag : tags){
            System.out.println(tag.name() + "-->" + tag.age());
        }


        
        // 多个重复注解实际上作为"容器注解"的成员变量[数组元素]存储,相当于传统"容器"注解写法的简化，底层实现是一致的
        // 因此虽然没有显式使用，仍可以获取到该"容器"注解
        // 使用传统的getDeclaredAnnotation()方法获取 修饰FkTagTest类的"容器"注解FkTags 
        FkTags container = clazz.getDeclaredAnnotation(FkTags.class);
        System.out.println(container);
    }
}
```

## 14.3.4 TypeAnnotation
TypeAnnotation/类型注解:`ElementType.TYPE_PARAMETER``ElementType.TYPE_USE`，可以用在程序中任何用到类型的地方:
- 创建对象[new关键字创建]
- 类型转换
- 使用implements接口
- 使用throws抛出异常
- 所有程序元素

```java
// 定义一个标记TypeAnnotation
@Target(ElementType.TYPE_USE)
@interface NotNull{

}

/**
 * Java8 并没有提供默认的APT，这些注解不生效，需要开发者自己提供或使用第三方框架提供的APT
 * 无处不在的注解使程序代码更加健壮
 */
// 定义类时使用Type Annotation
@NotNull						/* implements时使用Type Annotation */
public class TypeAnnotationTest implements @NotNull  Serializable{
	// 方法形参中使用Type Annotation               	/* throws时使用Type Annotation */ 
	public static void main(@NotNull String[] args) throws @NotNull FileNotFoundException{
		Object obj = "fkjava.org";
		// 强制类型转换时使用Type Annotation
		String str = (@NotNull String)obj;
		// 创建对象时使用Type Annotation
		Object win = new @NotNull JFrame("疯狂软件"); 
	}
	// 泛型中使用Type Annotation
	public void foo(List<@NotNull String> info){}
}
```


