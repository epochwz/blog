### 不可变类的定义

**不可变类\(Immutable\)：**实例在整个生命周期中永远处于初始化状态\(成员变量不可改变\)

1. 定义`private final 成员变量`
2. 提供带参数构造器，用于初始化成员变量
3. 仅为该类成员变量提供getter，而不提供setter
4. 如有必要，重写hashCode\(\)和equals\(\)方法，保证equals判断为相等的对象的hashCode\(\)也相等

### **不可变类基础示例**

```java
public class Address{
    // 1. 成员变量private final 修饰
    private final String detail;
    private final String postCode;

    // 2. 提供有参构造器初始化成员变量
    public Address(String detail , String postCode){
        this.detail = detail;
        this.postCode = postCode;
    }

    // 3. 仅提供getter方法
    public String getDetail(){
        return this.detail;
    }
    public String getPostCode(){
        return this.postCode;
    }

    // 4. 重写equals()方法,自定义判断两个对象相等的标准
    public boolean equals(Object obj){
        // 如果两个对象为同一个对象
        if (this == obj){
            return true;
        }
        // 只有当obj不为null且是该类对象时
        if(obj != null && obj.getClass() == Address.class){
            Address ad = (Address)obj;
            // 自定义相等标准
            if (this.getDetail().equals(ad.getDetail()) && this.getPostCode().equals(ad.getPostCode())){
                return true;
            }
        }
        return false;
    }

    // 5. 重写hashCode()方法，定义其返回值由detail和postCode决定，保证equals判断相等的两个对象hashCode方法也相等
    public int hashCode(){
        return detail.hashCode() + postCode.hashCode() * 31;
    }
}
```

### 成员变量含有可变类的不可变类

**可变类：**该类的实例变量是可变的。大部分类都是可变类，尤其是JavaBean类都提供了getter和setter方法.

若不可变类的成员变量含有可变类，则该不可变类的设计是失败的，需要采取措施来保护该成员变量所引用的对象不被修改

```java
package jwz;

/**
 * 可变类Name
 */
class Name{
    private String firstName;
    private String lastName;
    public Name(){}
    public Name(String firstName , String lastName){
        this.firstName = firstName;
        this.lastName = lastName;
    }
    // firstName、lastName的setter和getter方法
    public void setFirstName(String firstName){
        this.firstName = firstName;
    }
    public String getFirstName(){
        return this.firstName;
    }
    public void setLastName(String lastName){
        this.lastName = lastName;
    }
    public String getLastName(){
        return this.lastName;
    }
}

/**
 * 含有引用类型变量[可变类]作为成员变量的的不完善的不可变类
 */
class Person{
    // 成员变量使用private final修饰
    private final Name name;

    // 提供带参构造器，确保成员变量不再被重新赋值
    public Person(Name name){
        this.name = name;
        // 改进做法：创建临时变量来赋值给实例，切断与形参对象的联系
        // this.name = new Name(name.getFirstName(),name.getLastName());
    }

    // 仅为实例变量提供getter,不提供setter
    public Name getName(){
        return name;
        // 改进做法：创建临时变量来返回供使用，避免直接返回的该实例被修改
        // return new Name(name.getFirstName(),name.getLastName());
    }

    // 省略重写equals||hashCode方法
}

/**
 * 测试：含有引用类型变量[可变类]的不完善的不可变类
 */
public class ImmutableTest{
    public static void main(String[] args){
        // 创建可变类对象
        Name n = new Name("大川", "欧");
        // 创建不可变类对象，并将可变类对象作为成员变量初始化值
        Person p = new Person(n);

    //  输出Person对象的name的firstName
        System.out.println(p.getName().getFirstName());

    // 试图通过可变类Name对象篡改不可变类Person的信息
        n.setFirstName("大傻逼");
        // 未改进时：Person对象的name的firstName值被改为"大傻逼"
        System.out.println(p.getName().getFirstName());

    // 试图通过不可变类Person返回的实例篡改信息
        p.getName().setFirstName("小傻逼");
        // 未改进时：Person对象的name的firstName值被改为"小傻逼"
        System.out.println(p.getName().getFirstName());
    }
}
```

### 缓存实例的不可变类

不可变类的实例的状态数据不可改变，可以方便的被多个对象共享

若程序需要经常使用相同的不可变类实例，则应该考虑缓存这种不可变类的实例\[重复创建相同的对象没有意义，且造成系统开销\]

```java
package jwz;

// 缓存实例的不可变类
class CacheImmutale{
    // 定义缓存实例的最大数量
    private static final int MAX_SIZE = 10;
    // 用于缓存实例的数组
    private static CacheImmutale[] cache = new CacheImmutale[MAX_SIZE];
    // 缓存实例的数组元素下标
    private static int pos = 0;

    // 缓存实例的名称
    private final String name;
    // 隐藏构造器避免随意创建实例，初始化实例名称，保证实例名称不可改变
    private CacheImmutale(String name){
        this.name = name;
    }
    // getter供获取实例名称
    public String getName(){
        return name;
    }
    // 不提供setter，防止重复赋值改变实例名称

    // 提供静态方法供获取实例
    public static CacheImmutale valueOf(String name){
        // 遍历已经缓存的实例
        for (int i = 0 ; i < MAX_SIZE; i++){
            // 如果实例已经被缓存，直接返回该实例
            if (cache[i] != null && cache[i].getName().equals(name)){
                return cache[i];
            }
        }
        // 缓存数组已满
        if (pos == MAX_SIZE){
            // 覆盖最早缓存的实例
            cache[0] = new CacheImmutale(name);
            // 下标右移
            pos = 1;
        }else{
            // 缓存该实例，下标右移
            cache[pos++] = new CacheImmutale(name);
        }
        return cache[pos - 1];//返回该实例

    }

    // 重写equals方法
    public boolean equals(Object obj){
        if(this == obj){
            return true;
        }
        if (obj != null && obj.getClass() == CacheImmutale.class){
            CacheImmutale ci = (CacheImmutale)obj;
            return name.equals(ci.getName());
        }
        return false;
    }

    //重写hashCode方法
    public int hashCode(){
        return name.hashCode();
    }
}

// 测试缓存实例的不可变类
public class CacheImmutaleTest{
    public static void main(String[] args){
        // 第一次调用valueOf方法，创建实例名称为hello的实例并缓存
        CacheImmutale c1 = CacheImmutale.valueOf("hello");
        // 第二次调用valueOf方法，通过实例名称直接获取缓存中的实例
        CacheImmutale c2 = CacheImmutale.valueOf("hello");
        // 创建并缓存实例
        CacheImmutale c3 = CacheImmutale.valueOf("HelloWorld");
        System.out.println(c1 == c2);
        System.out.println(c3.getName());
    }
}
```