有一个Computer类需要组合一个输出设备。此时应该组合Printer类还是Output接口？

组合Printer，若有一天需要将该Computer的输出设备改进成BetterPrinter，则需要修改Computer类。若有成千上万组合了该Printer的不同类似Computer的类，则难以修改。

组合Output，则无须修改类似Computer的类，只需在工厂类改变生产的Printer类即可。

```java
package jwz;

 // 定义输出设备的接口规范：只要某个类能取得数据，并可以将数据输出，那它就是一个输出设备
 // 输出设备具体的实现细节该规范并不关心。
 interface Output{
  // 接口里定义的成员变量默认public static final修饰
  int MAX\_CACHE\_LINE = 50;

 // 接口里定义的普通方法默认public abstract修饰
  // 输出的方法
  void out\(\);
  // 获取数据的方法
  void getData\(String msg\);

 // 定义输出的默认方法，需要使用default修饰
  default void print\(String... msgs\){
      for \(String msg : msgs\){
          System.out.println\(msg\);
      }
  }

 // 定义类方法
  static String staticTest\(\){
      return "接口里的类方法";
  }
 }

 // Output接口的实现类：普通打印机
 class Printer implements Output{
  // 该数组存放将要打印的内容
  private String\[\] printData = new String\[MAX\_CACHE\_LINE\];
  // 用以记录当前需打印的作业数
  private int dataNum = 0;
  // 实现并重写打印内容的方法
  public void out\(\){
      // 只要还有作业，继续打印
      while\(dataNum &gt; 0\){
          System.out.println\("打印机打印：" + printData\[0\]\);
          // 把作业队列整体前移一位，并将剩下的作业数减1
          System.arraycopy\(printData , 1 , printData, 0, --dataNum\);
      }
  }
  // 实现并重写获取数据的方法
  public void getData\(String msg\){
      if \(dataNum &gt;= MAX\_CACHE\_LINE\){
          System.out.println\("输出队列已满，添加失败"\);
      }else{
          // 把打印数据添加到队列里，已保存数据的数量加1。
          printData\[dataNum++\] = msg;
      }
  }
 }

 // Output接口的实现类：高速打印机
 class BetterPrinter implements Output{
  // 存放将要打印的内容
  private String\[\] printData = new String\[MAX\_CACHE\_LINE _ 2\];
  // 用以记录当前需打印的作业数
  private int dataNum = 0;
  // 打印的方法
  public void out\(\){
      // 只要还有作业，继续打印
      while\(dataNum &gt; 0\){
          System.out.println\("高速打印机正在打印：" + printData\[0\]\);
          // 把作业队列整体前移一位，并将剩下的作业数减1
          System.arraycopy\(printData , 1, printData, 0, --dataNum\);
      }
  }
  // 获取数据的方法
  public void getData\(String msg\){
      if \(dataNum &gt;= MAX\_CACHE\_LINE \* 2\){
          System.out.println\("输出队列已满，添加失败"\);
      }else{
          // 把打印数据添加到队列里，已保存数据的数量加1。
          printData\[dataNum++\] = msg;
      }
  }
 }

 // Output接口工厂:生产不同的Output接口实现类
 class OutputFactory{
  // 定义Output接口实例
  private Output output;
  public OutputFactory\(Output output\){
      this.output=output;
  }

 // 返回生产的Output接口实例
  public Output getOutput\(\){
      return this.output;
  }
 }

 // 电子产品的接口规范
 interface Product{
  // 定义一个模拟获取字符串输入的方法
  void keyIn\(String msg\);
  // 定义一个模拟打印的方法
  void print\(\);
  // 定义一个获取生产日期的方法
  long getProduceTime\(\);
 }

 // Product接口的实现类：计算机
 class Computer implements Product{
  // 定义计算机的输出设备\[组合Output接口\]
  private Output out;
  // 初始化计算机的输出设备
  public Computer\(Output out\){
      this.out = out;
  }

 // 实现Product接口的输入方法
  public void keyIn\(String msg\){
      out.getData\(msg\);
  }

 // 实现Product接口的输出方法
  public void print\(\){
      out.out\(\);
  }

 // 实现Product接口的获取生产日期的方法
  public long getProduceTime\(\){
      return System.currentTimeMillis\(\);
  }
 }

 // 测试：组合不同输出设备的电子产品\[Computer\]
   public class FactoryTest{
    // 测试工厂模式
    public static void main\(String\[\] args\){
        // 创建Output工厂对象，用于生产Output接口实现类{通过构造器传入不同的输出设备类型}
        OutputFactory of = null;
    // 生产普通打印机
    of=new OutputFactory(new Printer());
    // 生产高速打印机
    of=new OutputFactory(new BetterPrinter());

    // 创建计算机，并组合Output工厂生产的输出设备
    Product p = new Computer(of.getOutput());
    // 模拟获取数据
    p.keyIn("轻量级Java EE企业应用实战");
    p.keyIn("疯狂Java讲义");
    // 模拟打印数据
    p.print();
    // 模拟获取生产日期
    System.out.println("生产日期："+p.getProduceTime());

    // 调用Output接口中定义的默认方法
    System.out.println("Output接口的默认打印方法");
    of.getOutput().print("孙悟空" , "猪八戒" , "白骨精");
    // 调用Output接口 中定义的类方法
    System.out.println(Output.staticTest());


   }
}
```

将所有生产Output对象的逻辑集中在OutputFactory工厂类中管理，而所有需要使用Output对象的类只需要与Output接口耦合，而不需要与具体的实现类Printer耦合
