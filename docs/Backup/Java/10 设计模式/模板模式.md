**模板模式**

* 抽象类是从多个具有相同特征的类中抽象出来的一个抽象类，以其作为子类模板，避免子类设计的随意性

* 子类在抽象类基础上进行扩展，改造，但总体上保留抽象类的行为方式

* 抽象父类的普通方法依赖于一个抽象方法，而抽象方法的实现推迟到子类中提供不同实现

如果编写了一个抽象父类，提供多个子类的通用方法，并将一个或多个抽象方法留给子类实现，就是模板模式

**模板模式设计规则**

* 抽象父类只知道其子类应该包含怎样的方法，但无法准确知道子类该如何实现这些方法。父类可以只定义需要使用的某些方法，把不能实现的部分抽象成抽象方法，推迟到子类去实现。
* 父类可能包含需要调用其他系列方法的方法，这些被调方法可以由父类实现，也可以由子类实现。
* 父类里提供的方法只是定义了一个通用算法，其实现并不完全由自身实现，而必须依赖于其子类的辅助

**模板模式示例**

```java
package jwz;

import static java.lang.Math.PI;

// 抽象父类：定义交通工具的速度
abstract class Speed{
    private double turnRate;// 转速

    // 设置转速
    public void setTurnRate(double turnRate){
        this.turnRate = turnRate;
    }

    // 把返回车轮半径的方法定义成抽象方法
    public abstract double getRadius();

    // 定义计算速度的通用算法
    public double getSpeed(){
        // 速度等于 车轮半径 * 2 * PI * 转速
        return PI * 2 * getRadius() * turnRate;
    }
}

// 汽车类
class CarSpeed extends Speed{
    // 汽车半径：重写抽象父类Speed的获取半径的方法。
    public double getRadius(){
        return 0.25;
    }
}

// 单车类
class BikeSpeed extends Speed{
    // 单车半径：重写抽象父类Speed的获取半径的方法。
    public double getRadius(){
        return 0.5;
    }
}

/**
 * 可定义不同种类交通工具，只需要重写获取半径的方法即可。
 */
public class SpeedTest{
    public static void main(String[] args){
        CarSpeed cs = new CarSpeed();
        cs.setTurnRate(15);
        System.out.println(cs.getSpeed());

        System.out.println();

        BikeSpeed bs = new BikeSpeed();
        bs.setTurnRate(15);
        System.out.println(bs.getSpeed());

    }
}
```



