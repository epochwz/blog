# 获取依赖的三种方式
获取方法 | 描述 | 说明
---|---|---
原始方法 | 调用者通过new的方式直接获取被依赖对象 | 导致调用者与被依赖对象的实现类硬编码耦合
简单工厂模式 | 工厂类负责创建被依赖对象,调用者通过工厂类获取被依赖对象 | 避免了类层次的耦合,但调用者与被依赖对象的工厂类耦合
依赖注入 | Ioc容器为调用者注入被依赖对象,调用者获取被依赖对象的方式由原来的主动获取变成了被动接受[IoC] | 通过XML配置来驱动Java代码,将原本由代码管理的依赖关系提取到XML配置文件中管理,实现系统中各组件的解耦

# 配置容器中的Bean
Spring容器中的一切对象[Java对象/数据源/Hibernate SessionFactory等基础性资源]统称为Bean

Spring容器是整个应用的超级大工厂,根据注解/XML配置文件，利用反射创建、管理容器中的Bean，并为其注入依赖关系
```xml
<!--<bean />元素默认驱动Spring容器调用实现类的无参构造器来创建实例,并将该实例作为容器中的Bean-->
<!--id:指定该Bean的唯一标识,Spring容器根据id管理Bean,程序通过id获取Bean实例-->
<!--class:指定该Bean的实现类,Spring容器使用XML解析器读取该属性值并通过反射创建该实现类的实例-->
<!--class属性的值必须是实现类的完整类名,不能是接口/抽象类,否则Spring无法使用反射创建实例-->
<bean id="steelAxe" class="org.jwz.demo.impl.SteelAxe"/>
```

# 配置Bean的依赖关系
```xml
<bean id="chinese" class="org.jwz.demo.impl.Chinese">
    <!--
        <property />元素驱动Spring容器创建Bean实例后,立即调用对应的setter方法注入其依赖关系
        name属性:决定具体执行的setter方法,例如此处为setAxe(new SteelAxe())
    -->
    <property name="axe" ref="steelAxe"/>
</bean>
<bean id="chinese" class="org.jwz.demo.impl.Chinese">
    <!--
        n个<constructory-arg />元素驱动Spring容器执行带n个参数的构造器来创建Bean实例的同时完成依赖关系的注入
        index属性:决定该构造参数值在构造器中的位置,例如此处为第一个
    -->
    <constructor-arg ref="stoneAxe" index="0" />
</bean>
```

## 配置Bean的依赖关系的参数值
```xml
<!--1. value:注入 基本类型及其包装类、String类型的值-->
<!--    使用java.beans.PropertyEditor完成类型转换-->
<property name="name" value="中国人"/>

<!--2. ref:注入 合作者Bean[容器中的其他Bean]-->
<property name="axe" ref="steelAxe"/>

<!--3. <bean />:注入 嵌套Bean[不能被Spring容器访问、仅仅用于依赖注入的Bean,因此无须id属性]-->
<!--    嵌套Bean提高了程序的内聚性,降低了灵活性.-->
<!--    只有在完全确定无需通过Spring容器访问某个Bean实例时才考虑使用嵌套Bean来配置该Bean-->
<property name="axe">
    <bean class="org.jwz.properties.impl.SteelAxe"/>
</property>

<!--4. 注入Java集合、数组 作为依赖关系的参数值-->

    <!--注入 List类型集合/数组 作为依赖关系的参数值-->
    <list>
        <value>小学</value>
        <value>中学</value>
        <value>大学</value>
    </list>
    <!--注入 Map集合 作为依赖关系的参数值-->
    <map>
        <!--Map元素的value是容器中的其他Bean-->
        <entry key="原始社会" value-ref="stoneAxe" />
        <entry key="农业社会" value-ref="steelAxe" />
        <!--Map元素的value是基本数据类型-->
        <entry key="数学" value="87" />
        <entry key="英语" value="87" />
    </map>
    <!--注入 Properties集合 作为依赖关系的参数值-->
    <props>
        <prop key="血压">正常</prop>
        <prop key="身高">184</prop>
    </props>
    
    <!--注入 Set类型集合 作为依赖关系的参数值-->
    <set>
        <!--Set元素的值可以是任意类型-->
        <value>普通的字符串</value>
        <bean class="org.jwz.demo.impl.StoneAxe" />
        <ref bean="stoneAxe" />
        <list>
            <value>20</value>
            <set>
                <value type="int">30</value>
            </set>
        </list>
    </set>
```
# 组合属性
```xml
<!--驱动Spring调用getPerson().setName("纪伟忠");-->
<!--其中person属性不能为null,否则getPerson将出现空指针异常-->
<property name="person.name" value="纪伟忠" />
```

# 设值注入和构造注入
设值注入
- 对于复杂的依赖关系,构造注入将导致构造器臃肿,且在创建Bean实例时需要实例化其依赖的所有实例,降低系统性能
- 成员变量可选的情况下，多参数构造器更加笨重

构造注入
- 可在构造器中清晰地决定依赖关系的注入顺序，优先依赖优先注入
- 对于依赖关系无需变化的Bean,没有setter方法,所有依赖关系在构造器内设定,可防止后续代码对依赖关系的破坏
- 组件的依赖关系只能在构造器中设定,则只有组件的创建者才能改变,而对调用者来说完全透明,符合高内聚

对于依赖关系无需变化的注入,采用构造注入,其余采用设值注入