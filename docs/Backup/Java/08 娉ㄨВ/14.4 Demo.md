# 注解处理工具APT
APT[Annotation Processing Tools]: 注解处理工具，对源代码文件进行检测，并找出源文件所包含的一种或多种 Annotation，然后针对 Annotation 信息进行额外的处理

APT必须实现javax.annotation.processing.Processor 接口:必须实现该接口所有方法，因此通常继承 AbstractProcessor 来实现 APT.

APT的目的是简化开发者的工作量
- APT可以在编译源代码时根据Annotation的信息生成一些源代码相关的附属文件[程序发布描述文件，配置文件等]，从而代替传统的对代码信息和附属文件的维护工作.
- APT 还会编译生成的源代码文件和原来的源文件，将他们一起生成class文件

cmd:`javac -processor APT 源文件`:编译时指定`-processor`选项，指定的APT 将在编译时提取并处理源文件中的 Annotation
- 例如：`javac -encoding utf-8 -d . -processor HibernateAnnotationProcessor Person.java`

# 编译源代码时自动生成Hibernate的映射文件*.hbm.xml
```java
import java.lang.annotation.*;

/**
 * 修饰持久化类
 */
@Target(ElementType.TYPE) 
@Retention(RetentionPolicy.SOURCE) // 仅在JAVA源文件中保留，运行时不能通过反射获取注解信息
@Documented
@interface Persistent{
    String table();
}

/**
 * 修饰标识属性
 */
@Target(ElementType.FIELD) 
@Retention(RetentionPolicy.SOURCE)
@Documented
@interface Id{
    String column();
    String type();
    String generator();
}

/**
 * 修饰普通成员变量
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.SOURCE)
@Documented
@interface Property{
    String column();
    String type();
}
```


```java
import java.lang.annotation.*;

/**
 * 定义持久化类
 */
@Persistent(table="person_info")
public class Person{
    @Id(column="person_id",type="integer",generator="identity")
    private int id;
    @Property(column="person_name",type="string")
    private String name;
    @Property(column="person_age",type="integer")
    private int age;

    //无参数的构造器
    public Person(){}
    //初始化全部成员变量的构造器
    public Person(int id , String name , int age){
        this.id = id;
        this.name = name;
        this.age = age;
    }

    //id的setter和getter方法
    public void setId(int id){
        this.id = id;
    }
    public int getId(){
        return this.id;
    }

    //name的setter和getter方法
    public void setName(String name){
        this.name = name;
    }
    public String getName(){
        return this.name;
    }

    //age的setter和getter方法
    public void setAge(int age){
        this.age = age;
    }
    public int getAge(){
        return this.age;
    }
}
```



```java
import java.lang.annotation.*;
import javax.annotation.processing.*;
import javax.lang.model.element.*;
import javax.lang.model.*;

import java.io.*;
import java.util.*;

/**
 * APT----提取Annotation信息并生成 Hibernate 映射文件
 */
@SupportedSourceVersion(SourceVersion.RELEASE_8)
// 指定可处理@Persistent、@Id、@Property三个Annotation
@SupportedAnnotationTypes({"Persistent" , "Id" , "Property"})
public class HibernateAnnotationProcessor extends AbstractProcessor{
    // 循环处理每个需要处理的程序对象
    public boolean process(Set<? extends TypeElement> annotations , RoundEnvironment roundEnv){
        // 定义一个文件输出流，用于生成额外的文件
        PrintStream ps = null;
        try{
            // 遍历每个被@Persistent修饰的class文件
            for (Element t : roundEnv.getElementsAnnotatedWith(Persistent.class)){
                // 获取正在处理的类名
                Name clazzName = t.getSimpleName();
                // 获取类定义前的@Persistent Annotation
                Persistent per = t.getAnnotation(Persistent.class);
                // 创建文件输出流
                ps = new PrintStream(new FileOutputStream(clazzName + ".hbm.xml"));
                // 执行输出
                ps.println("<?xml version=\"1.0\"?>");
                ps.println("<!DOCTYPE hibernate-mapping PUBLIC");
                ps.println("    \"-//Hibernate/Hibernate " + "Mapping DTD 3.0//EN\"");
                ps.println("    \"http://www.hibernate.org/dtd/" + "hibernate-mapping-3.0.dtd\">");
                ps.println("<hibernate-mapping>");
                ps.print("  <class name=\"" + t);
                // 输出per的table()的值
                ps.println("\" table=\"" + per.table() + "\">");
                for (Element f : t.getEnclosedElements()){
                    // 只处理成员变量上的Annotation
                    if (f.getKind() == ElementKind.FIELD){   // ①
                        // 获取成员变量定义前的@Id Annotation
                        Id id = f.getAnnotation(Id.class);      // ②
                        // 当@Id Annotation存在时输出<id.../>元素
                        if(id != null){
                            ps.println("        <id name=\""
                                + f.getSimpleName()
                                + "\" column=\"" + id.column()
                                + "\" type=\"" + id.type()
                                + "\">");
                            ps.println("        <generator class=\""
                                + id.generator() + "\"/>");
                            ps.println("        </id>");
                        }
                        // 获取成员变量定义前的@Property Annotation
                        Property p = f.getAnnotation(Property.class);  // ③
                        // 当@Property Annotation存在时输出<property.../>元素
                        if (p != null){
                            ps.println("        <property name=\""
                                + f.getSimpleName()
                                + "\" column=\"" + p.column()
                                + "\" type=\"" + p.type()
                                + "\"/>");
                        }
                    }
                }
                ps.println("    </class>");
                ps.println("</hibernate-mapping>");
            }
        }catch (Exception ex){
            ex.printStackTrace();
        }finally{
            if (ps != null){
                try{
                    ps.close();
                }catch (Exception ex){
                    ex.printStackTrace();
                }
            }
        }
        return true;
    }
}
```

# Junit测试框架的补充注解
```java
package jwz;

import java.lang.annotation.*;
import java.lang.reflect.*;

/**
 * 标记注解：用于标记哪些方法是可测试的，作为JUnit测试框架的补充。
 * 在JUnit框架中要求测试用例的测试方法必须以test开头，若使用该注解，则可把任何方法标记为可测试的。
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@interface Testable{

}

/**
 * 业务类，使用@Testable标记哪些方法是可测试的
 */
class MyTest{
    @Testable
    public static void m1(){}
    public static void m2(){}

    @Testable
    public static void m3(){
        throw new IllegalArgumentException("参数出错了！");
    }
    public static void m4(){}

    @Testable
    public static void m5(){}
    public static void m6(){}
    
    @Testable
    public static void m7(){
        throw new RuntimeException("程序业务出现异常！");
    }
    public static void m8(){}
}


/**
 * @Testable 的注解处理工具
 */
class ProcessorTest{
    public static void process(String clazz) throws ClassNotFoundException{
        int passed = 0;
        int failed = 0;
        // 遍历clazz对应的类里的所有方法
        for (Method m : Class.forName(clazz).getMethods()){
            // 如果该方法使用了@Testable修饰
            if (m.isAnnotationPresent(Testable.class)){
                try{
                    // 调用m方法
                    m.invoke(null);
                    // 测试成功，passed计数器加1
                    passed++;
                }catch (Exception ex){
                    System.out.println("方法" + m + "运行失败，异常："+ ex.getCause());
                    // 测试出现异常，failed计数器加1
                    failed++;
                }
            }
        }
        // 统计测试结果
        System.out.println("共运行了:" + (passed + failed)
            + "个方法，其中：\n" + "失败了:" + failed + "个，\n"
            + "成功了:" + passed + "个！");
    }
}

/**
 * 测试类
 */
public class RunTests{
    public static void main(String[] args) throws Exception{
        // 处理MyTest类
        ProcessorTest.process("jwz.MyTest");
    }
}
```


# 通过注解为程序绑定事件监听器
```java
package jwz;

import java.lang.annotation.*;
import java.awt.event.*;
import java.lang.reflect.*;
import java.awt.event.*;
import javax.swing.*;

/**
 * 自定义注解类：用于绑定事件监听器
 * 使用该注解时需要指定一个listener成员变量， 即指定监听器的实现类
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@interface ActionListenerFor{
    // 定义一个成员变量，保存监听器实现类
    Class<? extends ActionListener> listener();
}


/**
 * @ActionListenerFor 的注解处理工具
 */
class ActionListenerInstaller{
    // 处理Annotation的方法，其中obj是包含Annotation的对象
    public static void processAnnotations(Object obj){
        try{
            // 获取obj对象的类
            Class clazz = obj.getClass();
            // 获取指定obj对象的所有成员变量，并遍历每个成员变量
            for (Field f : clazz.getDeclaredFields()){
                // 将该成员变量设置成可自由访问。
                f.setAccessible(true);
                // 获取该成员变量上ActionListenerFor类型的Annotation
                ActionListenerFor a = f.getAnnotation(ActionListenerFor.class);
                // 获取成员变量f的值
                Object fObj  = f.get(obj);
                // 如果f是AbstractButton的实例，且a不为null
                if (a != null && fObj != null && fObj instanceof AbstractButton){
                    // 获取a注解里的listner元数据（它是一个监听器类）
                    Class<? extends ActionListener> listenerClazz = a.listener();
                    // 使用反射来创建listner类的对象
                    ActionListener al = listenerClazz.newInstance();
                    AbstractButton ab = (AbstractButton)fObj;
                    // 为ab按钮添加事件监听器
                    ab.addActionListener(al);
                }
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}



// 定义ok按钮的事件监听器实现类
class OkListener implements ActionListener{
    public void actionPerformed(ActionEvent evt){
        JOptionPane.showMessageDialog(null , "单击了确认按钮");
    }
}
// 定义cancel按钮的事件监听器实现类
class CancelListener implements ActionListener{
    public void actionPerformed(ActionEvent evt){
        JOptionPane.showMessageDialog(null , "单击了取消按钮");
    }
}

/**
 * 测试类
 */
public class AnnotationTest{
    private JFrame mainWin = new JFrame("使用注解绑定事件监听器");
    
    // 使用Annotation为ok按钮绑定事件监听器
    @ActionListenerFor(listener=OkListener.class)
    private JButton ok = new JButton("确定");
    // 使用Annotation为cancel按钮绑定事件监听器
    @ActionListenerFor(listener=CancelListener.class)
    private JButton cancel = new JButton("取消");

    public void init(){
        // 初始化界面的方法
        JPanel jp = new JPanel();
        jp.add(ok);
        jp.add(cancel);
        mainWin.add(jp);
        ActionListenerInstaller.processAnnotations(this);     // ①
        mainWin.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        mainWin.pack();
        mainWin.setVisible(true);
    }
    public static void main(String[] args){
        new AnnotationTest().init();
    }
}
```