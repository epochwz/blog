java.lang.annotation包下提供6个 Meta Annotation/元注解

## 14.2.1 使用@Retention
@Retention 只能用于修饰 Annotation，指定被修饰的 Annotation 作用范围。
- @Retention 包含一个 RetentionPolicy 类型的 value 成员变量，使用时必须为该value成员变量指定值:
    ```java
    RetentionPolicy.RUNTIME:编译器将 把 Annotation 记录在class文件中。当程序运行时，JVM 可通过反射获取 Annotation 信息
    RetentionPolicy.CLASS:编译器将 把 Annotation 记录在class文件中。当运行程序时，JVM 不可获取 Annotation 信息。默认值
    RetentionPolicy.SOURCE:Annotation 只保留在源代码中，编译器直接丢弃这种 Annotation
    ```
- 指定 Annotation 成员变量值的代码:`@Retention( value= RetentionPolicy.RUNTIME )`
- 只需要为成员变量value指定值时，可以省略变量名:`@Retention(RetentionPolicy.RUNTIME)`

## 14.2.2 使用@Target
@Target 只能修饰 Annotation 定义，用于指定被修饰的 Annotation 能用于修饰哪些程序元素。
- @Target 包含一个 ElementType 类型的 value 成员变量，使用时必须为该value成员变量指定值:
    ```java
    ElementType.ANNOTATION_TYPE:指定该 Annotation 只能修饰 Annotation
    ElementType.CONSTRUCTOR:只能修饰构造器
    ElementType.FIELD:只能修饰成员变量
    ElementType.LOCAL_VARIABLE:只能修饰局部变量
    ElementType.METHOD:只能修饰方法定义
    ElementType.PACKAGE:只能修饰包定义
    ElementType.PARAMETER:修饰参数
    ElementType.TYPE:可以修饰类、接口[包含注解类型]或枚举定义
    ```

## 14.2.3 使用@Documented
@Documented 用于指定被该 Meta Annotation 修饰的 Annotation 将被javadoc工具提取，所有使用该 Annotation 修饰的程序元素的API文档中将会包含该 Annotation 说明

## 14.2.4 使用@Inherited
@Inherited 用于指定被该 Meta Annotation 修饰的 Annotation 将具有继承性：如果某类使用了 @XXX 修饰[定义 @XXX 时使用了 @Inherited 修饰]，则其子类自动被 @XXX 修饰

```java
import java.lang.annotation.*;

@Inherited
@interface AnnoTest{

}

// 该Annotation被@Inherited修饰，具有继承性，其子类无须声明该Annotation
@AnnoTest
class Base{

}

public class Sub extends Base{
    public static void main(String[] args) {
        // 输出true,说明该类被@AnnoTest修饰了
        System.out.println(Sub.class.isAnnotationPresent(AnnoTest.class));
    }
}
```