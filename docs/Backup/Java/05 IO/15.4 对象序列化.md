对象序列化目标:将对象保存到磁盘中或允许在网络中直接传输对象，使对象可以脱离程序的运行而独立存在。

对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，将这种二进制流保存在磁盘上，或通过网络将其传输到另一个网络节点。其他程序可将该二进制流恢复成原来的java对象

## 15.8.1 序列化的含义和意义
- 对象的序列化指将一个对象写入IO流中，反序列化则指从IO流中恢复该对象
- 让某个对象支持序列化，必须让它的类实现两个接口之一:Serializable||Externalizable
- Serializable接口是一个标记接口，没有任何方法，只是表明某类是可序列化的
- 所有网络上传输的对象的类必须是可序列化的，否则异常。例如RMI[远程方法调用,JavaEE 的基础]过程中的参数和返回值都必须实现序列化。
- 所有需要保存到磁盘的对象的类必须是可序列化的。Web 应用需要保存到 HttpSession||ServletContext 属性的Java对象
- Tip:序列化机制是JavaEE平台的基础。建议每个 JavaBean 类都实现 Serializable

## 15.8.2 使用对象流实现序列化
序列化:
1. 创建 ObjectOutputStream [处理流，必须建立在其他节点流的基础之上]
2. 调用 ObjectOutputStream 对象的 writeObject()方法输出可序列化对象。

反序列化:
1. 创建一个 ObjectInputStream 输入流 [处理流，必须建立在其他节点流的基础之上]
2. 调用 ObjectInputStream 对象的 readObject()方法读取流中的对象,返回一个 Object 类型的 Java 对象，使用时需要强制类型转换

- 反序列化读取的仅仅是Java对象的数据，而非Java类，因此恢复对象时必须提供该对象所属类的class文件，否则异常
- 反序列化无须通过构造器来初始化对象[不会调用其构造器]
- 若向文件写入了多个对象，则恢复对象时必须按实际写入顺序读取
- 当一个可序列化类有多个父类时[直接和间接父类],这些父类要么有无参构造器，要么可序列化，否则异常。若父类不可序列化，只是有无参构造器，则该父类的成员变量值不会被序列化到流中    

## 15.8.3 对象引用的序列化
如果某类拥有引用类型的成员变量，则该引用类型必须是可序列化的，否则该类不可序列化
- 例如：当 Teacher 类被序列化时，为了反序列化时可以正常恢复该对象，程序会顺带将 Person 对象也序列化。
Java 序列化机制采用了特殊的序列化算法:
- 所有保存到磁盘的对象都有一个序列化编号
- 当程序试图序列化一个对象时，会先检查该对象是否已经被序列化过
    - 若无，则将该对象转换成字节序列并输出
    - 若有，则直接输出一个序列化编号，而非重新序列化该对象
    - 即，当多次调用writeObject()输出同一个对象时，只有第一次调用才会将该对象转换成资字节序列并输出。
    - 当程序序列化一个可变对象时，只有第一次调用writeObject方法才会将该对象转换成资字节序列并输出,即使后面该对象的实例变量已经被改变，改变的实例变量值也不会被输出

## 15.8.4 自定义序列化
递归序列化:序列化某个对象时，系统会自动序列化其实例变量，若实例变量引用到另一个对象，则引用的对象也会被序列化，依次类推，直至序列化完成

transient:指定序列化时忽略其修饰的实例变量。
    一个类里包含的某些实例变量时敏感信息，如银行账号信息
    某个实例变量的类型是不可序列化的，因此不希望对其进行递归序列化，以免引发 java.io.NotSerializableException

自定义序列化机制:让程序控制如何序列化各实例变量，甚至完全不实例化某变量[=transient]

自定义序列化的类需要提供以下方法:
- private void writeObject(java.io.ObjectOutputStream out) throws IOException     :负责写入特定类的实例状态，默认调用out.defaultWriteObject 来保存对象的各实例变量，通过重写获得对序列化的控制
- private void readObject(java.io.ObjectInputStream in) throws IOException,ClassNotFoundException :从流中读取并恢复对象实例变量，默认调用 in.defaultReadObject 来恢复对象的非瞬态实例变量。
- private void readObjectNoData() throws ObjectStreamException:当序列化流不完整时，该方法可以用来正确的初始化反序列化的对象。发送方的反序列化类不同于接收方或流被篡改时，系统都将调用该方法

序列化时替换对象:[修饰符] Object writeReplace() throws ObjectStreamException:序列化机制在序列化对象之前，先调用其writeReplace方法，若该方法返回另一个对象，则系统转为序列化另一个对象并再次调用其writeReplace方法，直至该方法不再返回另一对象，调用其writeObject方法保存该对象的状态
保护性复制整个对象:
    - [修饰符] Object readResolve() throws ObjectStreamException:紧接着readObject之后被调用，其返回值会代替原来反序列化的对象，而readObject反序列化的对象会被立即丢弃
    - 常用于序列化单例类、枚举类。反序列化机制在恢复对象时无须调用构造器，因此可以绕过private构造器"克隆"对象。而该方法可以避免这种情况
    - Tip:final 类重写readResolve方法没有任何问题，否则，重写时应尽量使用private修饰该方法。[否则没有重写该方法的子类将反序列化得到父类对象]

## 15.8.5 另一种自定义序列化机制
完全由程序员决定存储和恢复对象数据，Java 类必须实现 Externalizable 接口
- void readExternal(ObjectInput in):该方法来实现反序列化。该方法调用 DataInput[ObjectInput 的父接口]方法来恢复基本类型的实例变量值，调用 ObjectInput 的 readObject 方法来恢复引用类型的实例变量值
- void writeExternal(ObjectOutput out):该方法来实现反序列化.同上

类似上述自定义序列化，只是该接口强制自定义序列化。

## 15.8.6 版本
    