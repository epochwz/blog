## 16.5.1 线程安全问题
当使用多个线程来访问同一个数据时容易出现线程安全问题

经典线程安全问题--银行取钱：
1. 用户输入账号、密码，系统判断用户的账号、密码是否匹配
2. 用户输入取款金额
3. 系统判断账号余额是否大于取款金额，是则取款成功；否则取款失败

模拟该问题的代码如下：
```java
/**
 * 账号类
 */
class Account{
    // 封装账户编号、账户余额的两个成员变量
    private String accountNo;
    private double balance;

    // 构造器
    public Account(){}
    public Account(String accountNo , double balance){
        this.accountNo = accountNo;
        this.balance = balance;
    }

    // accountNo的setter和getter方法
    public void setAccountNo(String accountNo){
        this.accountNo = accountNo;
    }
    public String getAccountNo(){
        return this.accountNo;
    }

    // balance的setter和getter方法
    public void setBalance(double balance){
        this.balance = balance;
    }
    public double getBalance(){
        return this.balance;
    }

    // 下面两个方法根据accountNo来重写hashCode()和equals()方法
    public int hashCode(){
        return accountNo.hashCode();
    }
    public boolean equals(Object obj){
        if(this == obj)
            return true;
        if (obj !=null && obj.getClass() == Account.class){
            Account target = (Account)obj;
            return target.getAccountNo().equals(accountNo);
        }
        return false;
    }
}
```
```java
/**
 * 模拟用户取钱的普通线程类[不安全]
 */
class DrawThread extends Thread{
    // 模拟用户账户
    private Account account;
    // 当前取钱线程所希望取的钱数
    private double drawAmount;
    public DrawThread(String name , Account account , double drawAmount){
        super(name);
        this.account = account;
        this.drawAmount = drawAmount;
    }
    // 当多条线程修改同一个共享数据时，将涉及数据安全问题。
    public void run(){
        // 账户余额大于取钱数目
        if (account.getBalance() >= drawAmount){
            // 吐出钞票
            System.out.println(getName() + "取钱成功！吐出钞票:" + drawAmount);
            // 强制制造错误：该线程修改余额前，使当前线程休眠1毫秒，此时另外一个取钱线程会被调度，从而引发数据错误
            try{
                Thread.sleep(1);
            }catch (InterruptedException ex){
                ex.printStackTrace();
            }
            // 修改余额
            account.setBalance(account.getBalance() - drawAmount);
            System.out.println("\t余额为: " + account.getBalance());
        }else{
            System.out.println(getName() + "取钱失败！余额不足！");
        }
    }
}
```
```java
package jwz;

/**
 * 多线程取钱测试类
 */
public class Test{
    public static void main(String[] args){
        // 创建一个账户
        Account acct = new Account("1234567" , 1000);
        // 普通线程：模拟两个线程对同一个账户取钱
        new DrawThread("甲" , acct , 800).start();
        new DrawThread("乙" , acct , 800).start();
    }
}
```

## 16.5.2 同步代码块
- run方法体不具有同步安全性--程序中有两个并发线程在修改Account对象，且系统恰好在A线程取钱后尚未修改余额时切换到取钱线程B，因此出现数据错误。
- Java的多线程支持引入了同步监视器来解决该问题，使用同步监视器的通用方法就是同步代码块，语法格式如下：
    ```java
    // 该方法参数obj就是同步监视器
    synchronized(obj){
        // 此处代码就是同步代码块
    }
    ```
- 线程开始执行同步代码块之前，必须先获得对同步监视器的锁定
- 任何时候只能有一个线程可以获得对同步监视器的锁定，当同步代码块执行完成后，该线程会释放对该同步监视器的锁定。
- 使用同步监视器的目的：阻止两个线程对同一个共享资源进行并发访问。
- 通常推荐使用可能被并发访问的共享资源充当同步监视器[例如上述银行问题，该共享资源是Account对象,将其作为同步监视器。]

修改用户取钱的线程类如下：
```java
// 当多条线程修改同一个共享数据时，将涉及数据安全问题：同步代码块实现线程安全
public void run(){
    // 使用Account对象作为同步监视器，任何线程进入下面同步代码块之前，
    // 必须先获得对account账户的锁定――其他线程无法获得锁，也就无法修改它
    // 这种做法符合：“加锁 → 修改 → 释放锁”的逻辑
    // 保证并发线程在任何时刻只有一个线程可以进入修改共享资源的代码区[临界区],从而保证线程的安全性。
    synchronized (account){
        // 账户余额大于取钱数目
        if (account.getBalance() >= drawAmount){
            // 吐出钞票
            System.out.println(getName() + "取钱成功！吐出钞票:" + drawAmount);
            try{
                Thread.sleep(2000);
            }catch (InterruptedException ex){
                ex.printStackTrace();
            }
            // 修改余额
            account.setBalance(account.getBalance() - drawAmount);
            System.out.println("\t余额为: " + account.getBalance());
        }else{
            System.out.println(getName() + "取钱失败！余额不足！");
        }
    }
    // 同步代码块结束，该线程释放同步锁
}
```

## 16.5.3 同步方法
- Java的多线程支持还提供了同步方法[使用synchronized关键字修饰的方法]
- synchronized 修饰的实例方法无须显式指定同步监视器，同步方法的同步监视器是this，即调用该方法的对象。
- 线程安全的类具有如下特征:
    1. 该类的对象可以被多个线程安全的访问
    2. 每个线程调用该对象的任意方法后能得到正确结果
    3. 每个线程调用该对象的任意方法后，该对象状态依然保持合理状态。
- 不可变类总是线程安全的，因为其对象状态不可改变，而可变对象需要额外的方法来保证其线程安全。

修改账户类如下：
```java
// 增加同步方法并取消balance的setter避免外部类随意修改其金额
// 任意时刻只能有一个线程获得对该对象的锁定，然后进入该同步方法执行取钱操作，保证多个线程并发取钱的线程安全。
public synchronized void draw(double drawAmount){
    // 账户余额大于取钱数目
    if (balance >= drawAmount){
        // 吐出钞票
        System.out.println("取钱成功！吐出钞票:" + drawAmount);
        // 强制制造错误：该线程修改余额前，使当前线程休眠1毫秒，此时另外一个取钱线程会被调度，从而引发数据错误
        try{
            Thread.sleep(1);
        }catch (InterruptedException ex){
            ex.printStackTrace();
        }
        // 修改余额
        balance-=drawAmount;
        System.out.println("\t余额为: " + balance);
    }else{
        System.out.println("取钱失败！余额不足！");
    }
}
```
修改测试类：
```java
// 当多条线程修改同一个共享数据时，将涉及数据安全问题：调用同步方法实现线程安全
public void run(){
    // 直接调用account对象的draw方法来执行取钱
    // 同步方法的同步监视器是this，this代表调用draw()方法的对象[此处即account]
    account.draw(drawAmount);
}
```

可变类的线程安全是以降低程序运行效率为代价的，为了减少线程安全的负面影响，采用如下策略：
- 不要对线程安全类的所有方法进行同步，只对那些会改变竞争资源的方法进行同步。如Account中的accountNo就无须同步。
- 若可变类有两种运行环境，单线程和多线程环境，则应该为其提供两种版本[线程安全和线程不安全]例如：StringBuilder在单线程环境保证较好的性能，StringBuffer实现线程安全。

## 16.5.4 释放同步监视器的锁定
任何线程进入同步代码块、同步方法之前必须先获得对同步监视器的锁定。

程序无法显式释放对同步监视器的锁定，线程在以下几种情况释放锁：
1. 当前线程的同步方法、同步代码块执行结束后释放
2. 当前线程在同步方法、同步代码块中碰到return/break等终止该代码块/方法的执行时释放
3. 当前线程在同步方法、同步代码块中碰到未处理的Error/Exception导致该代码块/方法异常结束时释放
4. 当前线程执行同步方法、同步代码块时，程序执行了同步监视器对象的wait方法，则当前线程暂停，释放同步监视器。

线程在以下几种情况下不会释放同步监视器：
1. 当前线程执行同步方法、同步代码块时，程序调用Thread.sleep()/Thread.yield()方法来暂停当前线程时，线程不释放
2. 当前线程执行同步代码块时，其他线程调用了该线程的suspend方法将该线程挂起，该线程不释放。程序应该尽量避免使用suspend/resume方法来控制线程

## 16.5.5 同步锁
- 更强大的线程同步机制：通过显式定义同步锁对象来实现同步，同步锁由Lock对象充当
- Lock提供了比synchronized方法和synchronized代码块更广泛的锁定操作，Lock允许实现更灵活的结构，可以具有差别很大的属性，且支持多个相关的Condition对象。
- Lock是控制多个线程对共享资源进行访问的工具。通常锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。
- 某些锁可能允许对共享资源的并发访问，如ReadWriteLock[读写锁]。
- Lock/ReadWriteLock接口：ReentrantLock[可重入锁]/ReentrantReadWriteLock实现类，ReentrantReadWriteLock为读写操作提供了三种锁模式:Writing,ReadingOptimistic,Reading
- StampedLock类可取代ReentrantReadWriteLock
- 实现线程安全的控制中比较常用的ReentrantLock可以显式的加锁，释放锁，使用代码格式如下：
    ```java
    class X{
        // 1. 定义锁对象
        private final ReentrantLock lock=new ReentrantLock();
        // 2. 定义需要保证线程安全的方法
        public void m(){
            // 3. 进入方法后立即请求对ReentrantLock对象加锁
            lock.lock();
            try{
                // 4. 执行需要保证线程安全的代码
                // method body
            }finally{
                // 5. 方法执行完毕后，使用finally块保证释放锁
                lock.unlock();
            }
        }
    }
    ```
- 使用Lock和使用同步方法类似，只是使用Lock时显式使用Lock对象作为同步锁，而使用同步方法时系统隐式使用当前对象作为同步监视器。都符合"加锁-修改-释放锁"的操作模式。
- 使用Lock对象时每个Lock对象都对应一个Account对象，一样可以保证对于同一个Account对象，同一时刻只能有一个线程进入临界区。
- 同步方法/代码块使用与竞争资源相关的、隐式的同步监视器，且强制要求加锁和释放锁要出现在同一个块结构中，当 获取多个锁时，必须以相反的顺序释放，且必须在与所有锁被获取时相同的范围内释放所有锁。
- Lock提供了更灵活的方式使用锁，包括非块结构的tryLock方法，试图获取中断锁的lockInterruptibly方法，获取超时失效锁的tryLock(long,TimeUnit)方法。
- ReentrantLock锁具有可重入性，一个线程对已被加锁的 ReentrantLock 锁再次加锁，ReentranLock对象维持一个计数器来追踪lock方法的嵌套调用，线程在每次调用lock加锁后，必须显式调用unlock来释放锁，所以一段被锁保护的代码可以调用另一个被相同锁保护的方法。

# 16.5.6 死锁
当两个线程相互等待对方释放同步监视器时就会发生死锁，所有线程处于阻塞状态，无法继续，JVM不会报异常，也没有任何提示，JVM不会采取措施处理死锁情况，需要开发人员编程时避免。
```java
package jwz;

// 线程A
class A extends Thread{
    // 共享资源1
    public static synchronized void info(){
        System.out.println("线程"+Thread.currentThread().getName()+"获得了共享资源1");
        try{
            Thread.sleep(200);
        }catch (Exception e) {
            System.out.println("异常");
        }
        System.out.println("线程"+Thread.currentThread().getName()+"试图获取共享资源2");
        B.info();
        System.out.println("线程"+Thread.currentThread().getName()+"释放了共享资源1");
    }
    public void run(){
        System.out.println("线程"+Thread.currentThread().getName()+"开始执行");
        info();
        System.out.println("线程"+Thread.currentThread().getName()+"执行结束");
    }
}

class B extends Thread{
    // 共享资源2
    public static synchronized void info(){
        System.out.println("线程"+Thread.currentThread().getName()+"获得了共享资源2");
        try{
            Thread.sleep(200);
        }catch (Exception e) {
            System.out.println("异常");
        }
        System.out.println("线程"+Thread.currentThread().getName()+"试图获取共享资源2");
        A.info();
        System.out.println("线程"+Thread.currentThread().getName()+"释放了共享资源2");
    }
    public void run(){
        System.out.println("线程"+Thread.currentThread().getName()+"开始执行");
        info();
        System.out.println("线程"+Thread.currentThread().getName()+"执行结束");
    }
}

public class Test{
    public static void main(String[] args) {
        new A().start();
        new B().start();
    }
}
```