## 16.6.1 传统的线程通信
Object类的 wait(),notify(),notifyAll()方法实现线程通信功能，必须由同步监视器对象来调用：
- 同步方法的同步监视器：调用该方法的对象
- 同步代码块的同步监视器：synchronized后括号里的对象

三个方法作用如下:
1. wait():导致当前线程等待，直到其他线程调用该同步监视器的notify/notifyAll方法来唤醒该线程。
2. notify():唤醒此同步监视器上等待的单个线程。[若该同步监视器上的所有线程都在等待，则随机性唤醒其中一个]。只有当前线程放弃对同步监视器的锁定后[使用wait方法],才可以执行被唤醒的线程。
3. notifyAll():唤醒此同步监视器上等待的所有线程。只有当前线程放弃对该同步监视器的锁定后，才可以执行被唤醒的线程。

传统的线程通信示例：
```java
package jwz;

class Account{
    private String accountNo; // 账户
    private double balance; // 余额
    // 账户是否有存款
    private boolean flag = false;

    // 构造器
    public Account(){}
    public Account(String accountNo , double balance){
        this.accountNo = accountNo;
        this.balance = balance;
    }

    // 取款方法
    public synchronized void draw(double drawAmount){
        try{
            // 如果flag为假，表明账户中还没有人存钱进去，取钱方法阻塞
            if (!flag){
                wait();
            }else{
                // 执行取钱
                System.out.println(Thread.currentThread().getName() + " 取钱:" +  drawAmount);
                balance -= drawAmount;
                System.out.println("账户余额为：" + balance);
                // 将标识账户是否已有存款的旗标设为false。
                flag = false;
                // 唤醒其他线程
                notifyAll();
            }
        }catch (InterruptedException ex){
            ex.printStackTrace();
        }
    }

    // 存钱方法
    public synchronized void deposit(double depositAmount){
        try{
            // 如果flag为真，表明账户中已有人存钱进去，则存钱方法阻塞
            if (flag){
                wait();
            }else{
                // 执行存款
                System.out.println(Thread.currentThread().getName() + " 存款:" +  depositAmount);
                balance += depositAmount;
                System.out.println("账户余额为：" + balance);
                // 将表示账户是否已有存款的旗标设为true
                flag = true;
                // 唤醒其他线程
                notifyAll();
            }
        }catch (InterruptedException ex){
            ex.printStackTrace();
        }
    }
}

/**
 * 模拟用户取钱的线程
 */
class DrawThread extends Thread{
    // 模拟用户账户
    private Account account;
    // 当前取钱线程所希望取的钱数
    private double drawAmount;
    public DrawThread(String name , Account account , double drawAmount){
        super(name);
        this.account = account;
        this.drawAmount = drawAmount;
    }
    // 重复100次执行取钱操作
    public void run(){
        for (int i = 0 ; i < 100 ; i++ ){
            account.draw(drawAmount);
        }
    }
}

/**
 * 模拟用户存钱的线程
 */
class DepositThread extends Thread{
    // 模拟用户账户
    private Account account;
    // 当前取钱线程所希望存款的钱数
    private double depositAmount;
    public DepositThread(String name , Account account , double depositAmount){
        super(name);
        this.account = account;
        this.depositAmount = depositAmount;
    }
    // 重复100次执行存款操作
    public void run(){
        for (int i = 0 ; i < 100 ; i++ ){
            account.deposit(depositAmount);
        }
    }
}

/**
 * 模拟并发存取钱时的线程通信
 */
public class Test{
    public static void main(String[] args){
        // 创建一个账户
        Account acct = new Account("1234567" , 0);
        new DepositThread("存款者" , acct , 800).start();
        new DrawThread("取钱者甲" , acct , 800).start();
        new DrawThread("取钱者乙" , acct , 800).start();
        new DrawThread("取钱者丙" , acct , 800).start();
        // 程序最后将被阻塞：3个存款者需要300次操作，而程序中只有一个取款者，因此程序最后变成存款者线程一直在等待取款
        // 阻塞！=死锁，此处并没有相互等待同步锁的情况。
    }
}
```

## 16.6.2 使用Condition控制线程通信
若程序不使用 synchronized 关键字来保证同步[同步方法/同步代码块],而是直接使用 Lock对象来保证同步，则系统不存在隐式的同步监视器，也就不能使用上述三个方法来进行线程通信了。

Condition可以让那些已经得到Lock对象却无法继续执行的线程释放Lock对象，也可以唤醒其他处于等待的线程。

Condition将同步监视器方法[wait(),notify(),notifyAll()]分解成截然不同的对象，以便通过将这些对象与Lock对象组合使用，为每个对象提供多个等待集。

Lock对象代替了同步方法/同步代码块的同步监视器，Condition代替了同步监视器的功能。

Condition实例被绑定在Lock对象上，要获得其实例，调用Lock对象的newCondition方法即可。

Condition提供如下方法:await()、signal()、signalAll()

使用Condition控制线程通信示例：
```java
import java.util.concurrent.*;
import java.util.concurrent.locks.*;

class Account{
    // 显式定义Lock对象
    private final Lock lock = new ReentrantLock();
    // 获得指定Lock对象对应的Condition
    private final Condition cond  = lock.newCondition();

    // 封装账户编号、账户余额的两个成员变量
    private String accountNo;
    private double balance;
    // 标识账户中是否已有存款的旗标
    private boolean flag = false;

    public Account(){}
    // 构造器
    public Account(String accountNo , double balance){
        this.accountNo = accountNo;
        this.balance = balance;
    }

    public void draw(double drawAmount){
        // 加锁
        lock.lock();
        try{
            // 如果flag为假，表明账户中还没有人存钱进去，取钱方法阻塞
            if (!flag){
                cond.await();
            }else{
                // 执行取钱
                System.out.println(Thread.currentThread().getName() + " 取钱:" +  drawAmount);
                balance -= drawAmount;
                System.out.println("账户余额为：" + balance);
                // 将标识账户是否已有存款的旗标设为false。
                flag = false;
                // 唤醒其他线程
                cond.signalAll();
            }
        }catch (InterruptedException ex){
            ex.printStackTrace();
        }finally{// 使用finally块来释放锁
            lock.unlock();
        }
    }
    public void deposit(double depositAmount){
        lock.lock();
        try{
            // 如果flag为真，表明账户中已有人存钱进去，则存钱方法阻塞
            if (flag){
                cond.await();
            }else{
                // 执行存款
                System.out.println(Thread.currentThread().getName() + " 存款:" +  depositAmount);
                balance += depositAmount;
                System.out.println("账户余额为：" + balance);
                // 将表示账户是否已有存款的旗标设为true
                flag = true;
                // 唤醒其他线程
                cond.signalAll();
            }
        }catch (InterruptedException ex){
            ex.printStackTrace();
        }finally{// 使用finally块来释放锁
            lock.unlock();
        }
    }
}
```
## 16.6.3 使用阻塞队列控制线程通信
Queue接口的子接口BlockingQueue不作为容器，而是作为线程同步的工具。

特征:当生产者线程试图向BlockingQueue放入元素时，若该队列已满，则该线程被阻塞；当消费者线程试图从BlockingQueue中取出元素时，若该队列已空，则该线程被阻塞。

![BlockingQueue方法及其实现类][BlockingQueue]
```java
package jwz;

import java.util.concurrent.*;

public class Test{
    public static void main(String[] args) throws Exception{
        // 定义一个长度为2的阻塞队列
        BlockingQueue<String> bq = new ArrayBlockingQueue<>(2);
        bq.put("Java"); // 与bq.add("Java"、bq.offer("Java")相同
        bq.put("C++"); // 与bq.add("Java"、bq.offer("Java")相同

        // 当队列已满时，三种方式继续添加元素的结果：
        System.out.println(bq.offer("Java"));// 返回false
        bq.add("Ruby"); // 抛出异常 
        bq.put("Java"); // ① 阻塞线程。
    }
}
```
使用阻塞队列控制线程通信示例：
```java
package jwz;

import java.util.concurrent.*;

// 生产者队列
class Producer extends Thread{
    private BlockingQueue<String> bq;
    public Producer(BlockingQueue<String> bq){
        this.bq = bq;
    }
    public void run(){
        String[] strArr = new String[]{"Java","Struts","Spring"};
        for (int i = 0 ; i < 999999999 ; i++ ){
            System.out.println(getName() + "生产者准备生产集合元素！");
            try{
                Thread.sleep(200);
                // 尝试放入元素，如果队列已满，线程被阻塞
                bq.put(strArr[i % 3]);
            }catch (Exception ex){
                ex.printStackTrace();
            }
            System.out.println(getName() + "生产完成：" + bq);
        }
    }
}

// 消费者队列
class Consumer extends Thread{
    private BlockingQueue<String> bq;
    public Consumer(BlockingQueue<String> bq){
        this.bq = bq;
    }
    public void run(){
        while(true){
            System.out.println(getName() + "消费者准备消费集合元素！");
            try{
                Thread.sleep(5000);
                // 尝试取出元素，如果队列已空，线程被阻塞
                bq.take();
            }catch (Exception ex){
                ex.printStackTrace();
            }
            System.out.println(getName() + "消费完成：" + bq);
        }
    }
}

public class Test{
    public static void main(String[] args){
        // 创建一个容量为1的BlockingQueue
        BlockingQueue<String> bq = new ArrayBlockingQueue<>(1);
        // 启动3生产者线程
        new Producer(bq).start();
        // 启动消费者线程
        new Consumer(bq).start();
    }
}
```

[BlockingQueue]:http://note.youdao.com/yws/public/resource/19cc8a2d6058bd78bb4dc157fb70ad26/xmlnote/791D8A9CC7B44122BF54500CF1DA252C/2477 "BlockingQueue方法及其实现类"