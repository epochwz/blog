# 16.3 线程的生命周期
线程在其生命周期中要经过新建、就绪、运行、阻塞、死亡五种状态。尤其是在运行后，由于CPU需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换。

## 16.3.1 新建和就绪状态
- 程序使用new关键字创建了一个线程之后，该线程就处于新建状态，和其他Java对象一样，仅仅由Java虚拟机为其分配内存，并初始化其成员变量的值。此时的线程对象没有任何动态特征，也不会执行线程执行体。
- 当线程对象调用了start()方法后，该线程就处于就绪状态，JVM会为其创建方法调用栈和程序计数器，该状态的线程并没有开始运行，只是表示可以运行了。而何时运行取决于JVM里线程调度器的调度。

启动线程使用start方法而非run方法，否则系统将线程对象当成普通对象，随之将run方法当成普通方法，而非线程执行体，无法与其他线程并发执行。
```java
// 自定义线程
class MyThread extends Thread{
    public void run(){
        // getName()返回调用该方法的对象/线程的名字
        System.out.println("当前对象:"+getName());
        // Thread.currentThread().getName()总是返回当前线程的名字
        System.out.println("当前线程:"+Thread.currentThread().getName());
        for (int i=0;i<20 ;i++ ) {
            System.out.println(getName()+"\t"+i);
        }
    }
}
```
```java
// 因此以下两个"线程"无法并发执行
public static void main(String[] args) {
    new MyThread().run();
    new MyThread().run();
    
    // 新建线程对象
    Thread t=new MyThread();
    // 直接调用run方法，该对象成为普通对象
    t.run(); 
    // 普通对象没有start方法
    t.start();
}
```

## 16.3.2 运行和阻塞状态
- 若处于就绪状态的线程获得了CPU,开始执行run方法的线程执行体，则该线程处于运行状态。
- 若计算机只有一个CPU，则任何时刻只有一个线程处于运行状态。
- 而多处理器的机器上会有多个线程并行执行；当线程数大于处理器数时，依然存在多个线程在同个CPU轮换的现象。
- 一个线程开始运行后，不可能一直处于运行状态,其运行过程需要被中断，使其他线程获得执行的机会。
- 线程调度策略
    - 抢占式策略：系统给每个可执行的线程一个时间片来处理任务，时间片结束后剥夺其所占用的资源，系统会考虑线程优先级选择下一个线程
    - 协作式策略：只有当一个线程调用了sleep或yield方法后才会放弃所占用的资源，即必须由线程主动放弃。
- 以下情况线程进入阻塞状态：
    - 线程调用sleep方法主动放弃所占用的处理器资源
    - 线程调用阻塞式IO方法，在该方法返回之前，该线程被阻塞。
    - 线程试图获得一个同步监视器，当该同步监视器被其他线程所持有。
    - 线程在等待某个通知
    - 程序调用了线程的suspend()方法将其挂起。该方法容易导致死锁，应避免使用。
- 当前线程被阻塞后，其他线程就可以获得执行机会，被阻塞的线程会在合适的时候重新进入就绪状态，等待线程调度器调度。
- 以下情况可以解除阻塞，让线程重新进入就绪状态：
    - 调用sleep方法的线程经过了指定的时间
    - 线程调用的阻塞式IO方法已经返回
    - 线程成功获得试图获得的同步监视器
    - 其他线程发出了线程正在等待的通知
    - 处于挂起状态的线程被调用了resume恢复方法
- 线程状态转换图：

  ![线程状态转换图][state]

## 16.3.3 线程死亡
线程以如下三种方式结束，进入死亡状态
- run/call方法执行完成，线程正常结束
- 线程抛出一个未捕获的Execption/Error
- 直接调用线程的stop方法结束线程，该方法容易导致死锁，不推荐使用

isAlive():测试某个线程是否已经死亡:新建/死亡状态返回false，其他返回true

子线程一旦启动后，拥有和主线程相同的地位，不会受其影响，不随主线程的结束而结束。

只能对处于新建状态的线程调用start方法，否则引发IllegalThreadStateException
```java
public static void main(String[] args){
    // 新建状态
    Thread t=new MyThread();
    // 1. 运行状态调用start
    t.start(); // 新建状态->就绪状态，正常
    t.start(); // 运行状态->就绪状态，异常
    
    
    // 2. 死亡状态调用start
    t.start();
    while(true){
        System.out.println(t.getName()+"是否死亡:"+!t.isAlive());
        if (!t.isAlive()) {
            System.out.println(t.getName()+"是否死亡:"+!t.isAlive());
            t.start();
            break;
        }
    }
}
```

[state]: http://note.youdao.com/yws/public/resource/19cc8a2d6058bd78bb4dc157fb70ad26/xmlnote/E5D6B0C2C54B47D59E0DFD4195CAC57A/1787 "线程状态转换图"