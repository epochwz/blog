## 16.1.2 多线程的优势
多线程程序的并发性高，多个线程共享内存，极大的提高程序的运行效率
线程之间共享内存、文件句柄和其他每个进程应有的状态。多个线程共享同一个进程虚拟空间，包括进程代码段、进程公有数据等，很容易的实现相互之间的通信。

多线程优点：
1. 线程之间共享内存非常容易，而进程不可共享
2. 系统创建进程需要为其分配独立的内存空间，重新分配系统资源，而创建线程的代价小得多，使用多线程实现多任务并发效率高，性能好
3. Java 语言内置多线程功能的支持，而非调用底层操作系统的调度方式，从而简化多线程编程。

# 16.2 线程的创建和启动
Thread类代表线程，所有线程对象必须是Thread类或其子类的实例。

每个线程的作用是完成一定的任务：执行一段程序流[一段顺序执行的代码]。Java使用线程执行体来代表这段程序流。

## 16.2.1 继承Tread类创建线程类
1. 定义Thread类子类，并重写其run()方法，该方法代表线程需要完成的任务--线程执行体
2. 创建Thread子类实例，即创建线程对象
3. 调用线程对象的start()方法来启动该线程。

```java
// 1. 通过继承Thread类来创建线程类
public class FirstThread extends Thread{
    private int i ;
    // 重写run方法，run方法的方法体就是线程执行体
    public void run(){
        for ( ; i < 100 ; i++ ){
            // 当线程类继承Thread类时，直接使用this即可获取当前线程，因此可以直接调用getName()方法返回当前线程的名
            // 输出结果中不同线程的i互不影响--程序中每次创建线程对象都需要先创建FirstThread对象，因此i属于不同的实例变量。
            System.out.println(getName() +  " " + i);
        }
    }
    public static void main(String[] args){
        for (int i = 0; i < 100;  i++){
            // currentThread()方法是Thread的类方法，获取当前正在执行的线程对象--此处是主线程mian
            // getName()方法是Thread的实例方法，返回调用该方法的线程名字
            System.out.println(Thread.currentThread().getName() +  " " + i);
            if (i == 20){
            	// 创建、并启动第一条线程
            	new FirstThread().start();
            	// 创建、并启动第二条线程
            	new FirstThread().start();
            	// 该程序中总共有3个线程[主线程main]
            }
        }
    }
}
```
## 16.2.2 实现Runnable接口创建线程类
1. 定义Runnable接口实现类，并重写其run()方法，该方法代表线程需要完成的任务--线程执行体
2. 创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该对象才是真正的线程对象。
3. 调用线程对象的start()方法来启动该线程。
```java
// 2. 通过实现Runnable接口来创建线程类
public class SecondThread implements Runnable{
    private int i ;
    // run方法同样是线程执行体
    public void run(){
        for ( ; i < 100 ; i++ ){
        // 当线程类实现Runnable接口时，如果想获取当前线程，只能用Thread.currentThread()方法。
        // 多个线程可共享i变量----i属于线程target类，而不属于线程对象
        System.out.println(Thread.currentThread().getName() + "  " + i);
        }
    }
    
    public static void main(String[] args){
        for (int i = 0; i < 100;  i++){
            System.out.println(Thread.currentThread().getName() + "  " + i);
            if (i == 20){
            	// Runnable对象仅作为Thread对象的target,其包含的run方法仅作为线程执行体，而实际的线程对象依然得是Thread实例，只是该Thread实例负责执行其target的run方法
            	// Runnable接口是函数式接口，可使用Lambda改进此程序
            	SecondThread st = new SecondThread();     // ①
            	// 通过new Thread(target , name)方法创建新线程
            	new Thread(st , "新线程1").start();
            	new Thread(st , "新线程2").start();
            }
        }
    }
}
```
## 16.2.3 使用Callable和Future创建线程
- Callable接口像是Runnable接口的增强版，提供一个call()方法作为线程执行体，比run方法更强大：
    - 可以有返回值
    - 可以声明抛出异常
- 因此可以提供一个Callable对象作为Thread的target,而该线程的线程执行体就是call方法。
- 但Callable接口并非Runnable接口的子接口，不能直接作为Thread的target,且call方法还有返回值--若作为线程执行体被调用而非直接调用时无法获得该返回值。
- 于是提供Future接口，实现了Runnable接口，并为其提供一个FutureTask实现类，该实现类实现了Future和Runnable接口--可作为Thread的target
- 在Future接口定义几个公共方法来控制它关联的Callable任务[参考API]
- Callable接口有泛型限制，其泛型形参类型与call方法返回值类型相同，且Callable为函数式接口。
- 创建并启动线程的步骤：
    1. 创建Callable接口实现类，实现call方法[有返回值]，将其作为线程执行体,再创建Callable实现类的实例。
    2. 使用FutureTask类来包装Callable实例，该FutureTask对象封装该实例call方法的返回值
    3. 使用FutureTask对象作为Thread对象的target创建并启动新线程
    4. 调用FutureTask对象的get()方法获得子线程执行结束后的返回值
```java
package jwz;

import java.util.concurrent.*;

// 3. Callabel接口和Future接口实现类FutureTask
public class Test{
    public static void main(String[] args){
        // 先使用Lambda表达式创建Callable<Integer>对象
        // 再使用FutureTask来包装Callable对象
        FutureTask<Integer> task = new FutureTask<Integer>((Callable<Integer>)() -> {
            int i = 0;
            for ( ; i < 20; i++ ){
                System.out.println(Thread.currentThread().getName() + " 的循环变量i的值：" + i);
            }
            // call()方法可以有返回值
            return i;
        });
        
        // main线程
        for (int i = 0 ; i < 20; i++){
            System.out.println(Thread.currentThread().getName() + " 的循环变量i的值：" + i);
            if (i == 5){
                // 实质还是以Callable对象来创建、并启动线程
                new Thread(task , "有返回值的线程").start();
            }
        }
        
        try{
            // 获取线程返回值，该方法导致主线程被阻塞，直到call方法结束并返回为止
            System.out.println("子线程的返回值：" + task.get());
        }catch (Exception ex){
            ex.printStackTrace();
        }
    }
}
```
## 16.2.4 创建线程的三种方式的对比
- 实现Runnable/Callable接口的方式创建线程的优缺点：
    1. 线程类只是实现了接口，还可以继承其他类
    2. 多个线程可以共享一个target对象，适合多个相同线程来处理一份资源的情况，从而将CPU、代码和数据分开，形成清晰的模型，体现面向对象思想。
    3. 编程更加复杂，若需要访问当前线程，必须使用Thread.currentThread()方法
- 继承Tread类创建线程类的优缺点：
    1. 线程类已经继承了Thread类，所以不能再继承其他父类
    2. 编写简单，可直接使用this获得当前线程
- 通常推荐使用Runnable/Callable接口实现