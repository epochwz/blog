## 线程组和未处理的异常
- ThreadGroup表示线程组，可以对一批线程进行分类管理。Java允许程序直接对线程组进行控制，相当于同时控制这批线程。
- 用户创建的线程都属于指定线程组，若没有显式指定线程所属的线程组，则该线程属于默认线程组。
- 默认情况下，子线程和创建它的父线程处于同一个线程组内。
- 一旦线程加入指定线程组后，将一直属于该组直到该线程死亡，线程运行中途不能改变其所属的线程组。
```java
new Thread(ThreadGroup group,Runnable target,String name):新建一个以target的run方法作为线程执行体，名称为name的线程，并加入group线程组
Thread.getThreadGroup()返回一个线程组对象，代表该线程所属的线程组
new ThreadGroup(ThreadGroup group,String name):以指定的名字，指定的父线程组名字来创建新的线程组
```
- 线程组总会有一个名字，通过ThreadGroup的getName()获取，但不允许改变线程组的名字。
- 后台线程组：当该组最后一个线程执行结束或被销毁后，后台线程组自动销毁
```java
package jwz;

class MyThread extends Thread{
    // 提供指定线程名的构造器
    public MyThread(String name){
        super(name);
    }
    // 提供指定线程名、线程组的构造器
    public MyThread(ThreadGroup group , String name){
        super(group, name);
    }
    public void run(){
        for (int i = 0; i < 20 ; i++ ){
            System.out.println(getName() + " 线程的i变量" + i);
        }
    }
}
public class ThreadGroupTest{
    public static void main(String[] args){
        // 获取主线程所在的线程组，这是所有线程默认的线程组
        ThreadGroup mainGroup = Thread.currentThread().getThreadGroup();
        System.out.println("主线程组的名字：" + mainGroup.getName());
        System.out.println("主线程组是否是后台线程组：" + mainGroup.isDaemon());

        new MyThread("主线程组的线程").start();

        ThreadGroup tg = new ThreadGroup("新线程组");
        tg.setDaemon(true);
        System.out.println("tg线程组是否是后台线程组：" + tg.isDaemon());
        new MyThread(tg , "tg组的线程甲").start();
        new MyThread(tg , "tg组的线程乙").start();
    }
}
```
- 若线程执行过程中抛出一个未处理的异常，JVM在结束该线程之前会自动查找是否有对应的Thread.UncaughtExceptionHandler对象，若找到该处理器对象，则调用该对象的uncaughtException(Thread t,Throwable e)方法来处理该异常。
- Thread.UncaughtExceptionHandler 是Thread类的一个静态内部接口，该接口只有一个方法：void uncaughtException(Thread t,Throwable e),t代表出现异常的线程，e代表该线程抛出的异常
    - static setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh):为该线程类的所有线程实例设置默认的异常处理器
    - setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh):为指定的线程实例设置异常处理器
- ThreadGroup类实现了Thread.UncaughtExceptionHandler接口，所以每个线程所属的线程组将会作为默认的异常处理器。
- 当一个线程抛出未处理异常时，JVM 首先查找该异常对应的异常处理器[setUncaughtExceptionHandler方法设置的异常处理器]，若找到该异常处理器，则调用其处理该异常
否则，JVM将调用该线程组所属的线程组对象的 uncaughtException方法来处理该异常，流程如下:
1. 若该线程组有父线程组，则调用父线程组的 uncaughtException方法来处理该异常
2. 若该线程实例所属的线程类有默认的异常处理器[由 setDefaultUncaughtExceptionHandler设置的异常处理器],那么调用该异常处理器来处理异常
3. 若该异常对象是 ThreadDeath 的对象，则不做任何处理；否则将异常跟踪栈的信息打印到 System.err 错误输出流，并结束该线程。
```java
package jwz;

// 定义自己的异常处理器
class MyExHandler implements Thread.UncaughtExceptionHandler{
    // 实现uncaughtException方法，该方法将处理线程的未处理异常
    public void uncaughtException(Thread t, Throwable e){
        System.out.println(t + " 线程出现了异常：" + e);
    }
}
public class ExHandler{
    public static void main(String[] args){
        // 设置主线程的异常处理器
        Thread.currentThread().setUncaughtExceptionHandler(new MyExHandler());
        int a = 5 / 0;     // ①
        System.out.println("程序正常结束！");
        // 运行后可知：自定义的异常处理器确实捕获了异常并起了作用，但程序仍然无法正常结束。
        // 说明catch捕获异常时，异常不会向上传播给上一级调用者，而使用异常处理器进行处理后，异常仍然向上传播。
    }
}
```