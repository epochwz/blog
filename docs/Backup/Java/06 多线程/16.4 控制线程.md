## 16.4.1 join线程
Thread提供了join方法让一个线程等待另一个线程完成。当某个程序执行流中调用其他线程的join方法时，则该程序执行流被阻塞，直到join方法加入的线程执行完为止。

join方法通常由使用线程的程序调用，将大问题划分成小问题，每个小问题分配一个线程，当所有小问题得到处理后，再调用主线程来进一步操作。
```java
public static void main(String[] args) {
    Thread t=new MyThread();
    t.start();
    // main线程调用了t线程的join()方法，main线程必须等待线程t执行结束后才会向下执行，即被阻塞
    t.join();
}
```

## 16.4.2 后台线程
后台线程/精灵线程/守护线程：在后台运行的一种线程，任务是为其他线程提供服务。例如，JVM 的垃圾回收线程。
- setDaemon(true)方法可将线程设置为后台线程。
- isDaemon()方法用于判断指定线程是否为后台线程

前台线程创建的子线程默认是前台线程，后台线程创建的子线程默认是后台线程[main方法默认是前台线程]

如果所有前台线程都死亡，JVM会通知后台线程自动死亡。[JVM中只剩后台线程时，程序就没有运行的必要了，所以JVM也退出了]，但从其接收指令到做出反应，需要一段时间。

```java
要将某个线程设置为后台线程，必须在该线程启动之前设置:setDaemon(true)方法要在start方法之前调用
public static void main(String[] args){
	MyThread t = new MyThread();
	// 将此线程设置成后台线程
	t.setDaemon(true);
	// 启动后台线程
	t.start();
	for (int i = 0 ; i < 20 ; i++ ){
		System.out.println(Thread.currentThread().getName() + "  " + i);
	}
	// -----程序执行到此处，前台线程（main线程）结束------
	// 后台线程也应该随之结束，但JVM通知其死亡需要时间，因此后台线程计数超过20
}
```
## 16.4.3 线程睡眠：sleep
Thread.sleep(long millis)：让当前线程暂停millis毫秒，并进入阻塞状态，该方法受系统计时器和线程调度器的精度和准确度影响。

当线程调用sleep方法后，在其睡眠阶段，该线程不会获得执行的机会，即使系统中没有其他可执行线程。 

## 16.4.4 线程让步：yield
Thread.yield()：让当前正在执行的线程暂停，但不会阻塞该线程，只是将其转入就绪状态，等待系统的线程调度器重新调度一次[若没有优先级相同或更高的其他线程，该线程完全可能出现暂停后被立即重新调度]

当某个线程调用了yield方法暂停后，只有优先级>=该线程的就绪状态的线程才会获得执行的机会。

sleep和yield的区别：
- sleep方法暂停当前线程后，不理会其他线程的优先级，总是给其他线程执行的机会，而yield方法只会给优先级>=该线程的线程执行机会
- sleep方法使线程转入阻塞状态，直到超过指定时间才进入就绪状态。yield方法直接强制进入就绪状态。
- sleep方法声明抛出InterruptedException异常，所以调用时必须捕捉该异常或显式声明抛出该异常，而yield没有。
- sleep方法比yield方法有更好的移植性，通常不建议用yield方法来控制并发线程的执行。

## 16.4.5 改变线程优先级
- 每个线程执行时具有一定的优先级，优先级高的线程可以获得更多的执行机会。
- 每个线程默认的优先级与创建它的父线程优先级相同。main线程默认具有普通优先级。
- setPriority(int newPriority)/getPriority()：设置和返回指定线程的优先级.
- set方法参数是一个整数，范围1~10,也可以是常量MAX_PRIORITY=10/MIN_PRIORITY=1/NORM_PRIORITY=5.
- Java的10个优先级级别需要操作系统的支持，而大部分系统支持的优先级级别不一致，通常应优先使用常量，具有更好的移植性。
```java
// 改变主线程的优先级
Thread.currentThread().setPriority(6);
```