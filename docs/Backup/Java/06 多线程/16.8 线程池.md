# 16.8 线程池
线程池可以很好的提高性能，尤其是程序中需要创建大量生存期很短的线程时。

线程池在系统启动时即创建大量空闲的线程，程序将一个Runnable/Callable对象传给线程池，线程池就会启动一个线程来执行它们的run()/call()方法，执行结束后，该线程并不会死亡，而是再次返回池中成为空闲状态，等待执行下一个线程执行体。

线程池通过其最大线程数参数可以有效的控制系统中并发线程的数量，避免因为系统中包含大量并发线程时导致的系统性能剧烈下降，甚至JVM崩溃。

## 16.8.1 改进的线程池
Java5新增一个Executors工厂类来产生线程池，该类提供了几个静态工厂方法来创建线程池。
- ExecutorService对象代表线程池，可以尽快执行Runnable/Callable对象代表的线程
- ScheduledExecutorService是ExecutorService的子类，可以在指定延迟后执行线程任务
- work stealing池，相当于后台线程池，若前台线程都死亡了，该池中的线程会自动死亡。

用完一个线程池后，应该启动线程池的关闭序列。
- 调用其shutdown()方法:调用该方法后的线程池不再接收新任务，但会将以前所有已提交任务执行完成，然后池中所有线程都会死亡。
- 调用shutdownNow()方法：调用该方法后的线程池试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表

使用线程池来执行线程任务的步骤如下:
1. 调用Executors类的静态工厂方法创建一个代表线程池的ExecutorService对象
2. 创建Runnable/Callable实现类的实例作为线程执行任务
3. 调用ExecutorService对象的submit()方法来提交Runnable/Callable实例
4. 当不想提交任何任务时，调用shutdown()方法关闭线程池

```java
package jwz;

import java.util.concurrent.*;

public class ThreadPoolTest{
	public static void main(String[] args) throws Exception{
		// 创建一个具有固定线程数（6）的线程池
		ExecutorService pool = Executors.newFixedThreadPool(6);
		// 使用Lambda表达式创建Runnable对象
		Runnable target = () -> {
			for (int i = 0; i < 10 ; i++ ){
				System.out.println(Thread.currentThread().getName() + "的i值为:" + i);
			}
		};
		// 向线程池中提交两个线程
		pool.submit(target);
		pool.submit(target);
		// 关闭线程池
		pool.shutdown();
	}
}
```

## 16.8.2 增强的ForkJoinPool
为了充分利用多CPU、多核CPU的优势，可以考虑将一个大任务拆分成多个小任务，放到多个处理器上并行执行，完成后将执行结果合并起来即可

ForkJoinPool支持对一个任务拆分的并行计算和合并计算结果。是ExecutorService的实现类，即一种特殊的线程池。
- ForkJoinPool(int parallelism):创建一个包含parallelism个并行线程的ForkJoinPool
- ForkJoinPool commonPool():返回一个通用池，通用池的运行状态不受shutdown/shutdownNow的影响。除非程序直接执行System.exit(0)来终止虚拟机.

ForkJoinTask代表一个可以并行、合并的任务，是一个抽象类。还有两个抽象子类:RecursiveAction[代表有返回值的任务]和RecursiveTask[代表没有返回值的任务]。

![线程池工具类类图][]
```java
package jwz;

import java.util.concurrent.*;

// 继承RecursiveAction[没有返回值]来实现"可分解"的任务
class PrintTask extends RecursiveAction{
	// 每个“小任务”只最多只打印50个数
	private static final int THRESHOLD = 50;
	private int start;
	private int end;
	// 打印从start到end的任务
	public PrintTask(int start, int end){
		this.start = start;
		this.end = end;
	}
	@Override
	protected void compute(){
		// 当end与start之间的差小于THRESHOLD时，开始打印
		if(end - start < THRESHOLD){
			for (int i = start ; i < end ; i++ ){
				System.out.println(Thread.currentThread().getName() + "的i值：" + i);
			}
		}else{
			// 如果当end与start之间的差大于THRESHOLD时，即要打印的数超过50个
			// 将大任务分解成两个小任务。
			int middle = (start + end) / 2;
			PrintTask left = new PrintTask(start, middle);
			PrintTask right = new PrintTask(middle, end);
			// 并行执行两个“小任务”
			left.fork();
			right.fork();
		}
	}
}
public class ForkJoinPoolTest{
	public static void main(String[] args) throws Exception{
		ForkJoinPool pool = new ForkJoinPool();
		// 提交可分解的PrintTask任务
		pool.submit(new PrintTask(0 , 300));
		pool.awaitTermination(2, TimeUnit.SECONDS);
		// 关闭线程池
		pool.shutdown();
	}
}
```
```java
package jwz;

import java.util.concurrent.*;
import java.util.*;

// 继承RecursiveTask[有返回值]来实现"可分解"的任务
class CalTask extends RecursiveTask<Integer>{
	// 每个“小任务”只最多只累加20个数
	private static final int THRESHOLD = 20;
	private int arr[];
	private int start;
	private int end;
	// 累加从start到end的数组元素
	public CalTask(int[] arr , int start, int end){
		this.arr = arr;
		this.start = start;
		this.end = end;
	}
	@Override
	protected Integer compute(){
		int sum = 0;
		// 当end与start之间的差小于THRESHOLD时，开始进行实际累加
		if(end - start < THRESHOLD){
			for (int i = start ; i < end ; i++ ){
				sum += arr[i];
			}
			return sum;
		}else{
			// 如果当end与start之间的差大于THRESHOLD时，即要累加的数超过20个时
			// 将大任务分解成两个小任务。
			int middle = (start + end) / 2;
			CalTask left = new CalTask(arr , start, middle);
			CalTask right = new CalTask(arr , middle, end);
			// 并行执行两个“小任务”
			left.fork();
			right.fork();
			// 把两个“小任务”累加的结果合并起来
			return left.join() + right.join();    // ①
		}
	}
}
public class Sum{
	public static void main(String[] args) throws Exception{
		int[] arr = new int[100];
		Random rand = new Random();
		int total = 0;
		// 初始化100个数字元素
		for (int i = 0 , len = arr.length; i < len ; i++ ){
			int tmp = rand.nextInt(20);
			// 对数组元素赋值，并将数组元素的值添加到sum总和中。
			total += (arr[i] = tmp);
		}
		System.out.println(total);
		// 创建一个通用池
		ForkJoinPool pool = ForkJoinPool.commonPool();
		// 提交可分解的CalTask任务
		Future<Integer> future = pool.submit(new CalTask(arr , 0 , arr.length));
		System.out.println(future.get());
		// 关闭线程池
		pool.shutdown();
	}
}
```
[线程池工具类类图]:http://note.youdao.com/yws/public/resource/19cc8a2d6058bd78bb4dc157fb70ad26/xmlnote/6D833EF298994227896492B3389ADC9D/6853 "线程池工具类类图"