TCP/IP通信协议是一种可靠的网络协议，它在通信两端各建立一个Socket,从而在通信两端之间形成网络虚拟链路，两端程序可通过虚拟链路进行通信。

Java对基于TCP协议的网络通信提供了良好封装，使用Socket对象代表两端的通信端口，并通过Socket产生IO流来进行网络通信。

## 17.1.3 TCP协议基础
IP协议：Internet Protocol。通过使用IP协议，使 Internet 成为一个允许连接不同类型的计算机和不同操作系统的网络
IP协议只保证计算机能发送和接收分组数据，负责将消息从一个主机传送到另一个主机，消息在传送过程中被分割成一个个小包

TCP协议提供可靠并且无差错的通信服务，端对端协议。
TCP负责收集信息包，并将其按适当的次序放好传送，接收端收到后再将其正确的还原。保证了数据包在传送中准确无误。
TCP重发机制：当通信实体A发送一个消息给通信实体B后，需要收到B的确认信息，否则重发刚才发送的信息。从而提供可靠的通信连接。
凡是连接到Internet的计算机，都必须同时安装和使用TCP/IP两个协议。

## 17.3.2 使用ServerSocket创建TCP服务器端
ServerSocket类用于接收其他通信实体的连接请求，监听来自客户端的Socket连接，若无连接将一直处于等待状态。
Socket accept():若接收到一个客户端Socket的连接请求，则返回一个与之对应的Socket，否则该方法一直处于等待状态，线程阻塞
ServerSocket(int port,int backlog,InetAddress localAddr):用指定的端口port来创建一个ServerSocket,backlog改变连接队列长度，localAddr将该Socket绑定到指定的IP地址
```java
// 创建一个ServerSocket用于监听客户端Socket的连接请求
// 没有指定IP地址，默认绑定到本机IP地址
ServerSocket ss=new ServerSocket(30000);
// 循环监听客户端请求
while(true){
    // 每当接收到客户端的Socket请求时，服务器端也产生一个对应的Socket
    Socket s=ss.accept();
    // 通信内容
}

## 17.3.3 使用Socket进行通信
Socket(InetAddress/String remoteAddress,int port,InetAddress localAddr,int localPort):创建连接到指定远程主机、远程端口的Socket，并指定本地IP地址和本地端口。
```java
// 创建连接到本机、30000端口的Socket
// 该代码会连接到指定服务器，让服务器端的ServerSocket的accept()方法向下执行，于是服务器端和客户端产生一对相互连接的Socket
// 127.0.0.1总是代表本机地址
Socket s=new Socket("127.0.0.1",30000);
// 通信内容
```
两端Socket建立连接后则无须再区分服务器端/客户端，而是通过各自的Socket进行通信。
```java
package jwz;

import java.net.*;
import java.io.*;

public class Client{
    public static void main(String[] args) throws IOException{
    // 1. 为Socket连接服务器时指定超时时长
        // 创建无连接Socket
        Socket s=new Socket();
        // 连接远程服务器，1s没有连接上即认为连接超时
        // ??????
        s.connect(new InetAddress("127.0.0.1" , 30000),1000);

        // Socket socket = new Socket("127.0.0.1" , 30000);   // ①

    // 2. 为网络连接、读取操作指定超时时长，5秒后连接超时
        s.setSoTimeout(5000);
        try(
            // 将Socket对应的输入流包装成BufferedReader
            BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));
        ){
            // 进行普通IO操作
            String line = br.readLine();
            System.out.println("来自服务器的数据1：" + line);
            System.out.println("来自服务器的数据2：" + line);
        }catch(SocketTimeoutException ex){
            ex.printStackTrace();
        }
        // 关闭socket
        s.close();
    }
}
```
```java
package jwz;

import java.net.*;
import java.io.*;

public class Server{
    public static void main(String[] args) throws IOException{
        // 创建一个ServerSocket，用于监听客户端Socket的连接请求
        ServerSocket ss = new ServerSocket(30000);
        // 采用循环不断接受来自客户端的请求
        while (true){
            System.out.println("服务器正在等待连接。。。");
            // 每当接受到客户端Socket的请求，服务器端也对应产生一个Socket
            Socket s = ss.accept();
            // 将Socket对应的输出流包装成PrintStream
            PrintStream ps = new PrintStream(s.getOutputStream());
            // 进行普通IO操作
            ps.println("您好，您收到了服务器的新年祝福！");
            // 关闭输出流，关闭Socket
            ps.close();
            s.close();
        }
    }
}
```

## 17.3.4 加入多线程
BufferedReader的readLine()方法读取数据时，在该方法成功返回之前，线程被阻塞，程序无法继续执行。因此，服务器端应该为每个Socket单独启动一个线程，每个线程负责与一个客户端通信

客户端读取服务器数据的线程同样会被阻塞，所以系统应该单独启动一个线程，该线程专门负责读取服务器端数据。

C/S聊天室应用

## 17.3.5 记录用户信息
1. 客户端发送的信息必须由特殊标识--用于服务器端判断是公聊/私聊信息
2. 私聊信息，客户端会发送该消息的目的用户[私聊对象]给服务器端，服务器端如何将该信息发送给私聊对象。

## 17.3.6 半关闭的Socket
Socket提供两个半关闭的方法，只关闭Socket的输入/输出流，用以表示输出数据已经发送完成。
- shutdownInput():关闭Socket的输入流，程序还可通过该Socket的输出流输出数据
- shutdownOutput():关闭Socket的输出流，程序还可通过该Socket的输入流读取数据
- isInputShutdown():判断该Socket是否处于半读状态
- isOutputShutdown():判断该Sokcet是否处于半写状态

即使先后关闭该Sokcet实例的输入/输出流，该实例依旧没有被关闭，只是该Socket不能读，也不能输出数据而已。

关闭Socket实例的输入/输出流后，无法再次打开，因此该做法不适合保持持久通信状态的交互式应用，只适用于一站式的通信协议，例如HTTP协议----客户端链接到服务器端后，发送请求数据，发送完成后无须再次发送数据，只需要读取服务器端响应数据即可，当读取响应完成后，该Socket连接也被关闭了。