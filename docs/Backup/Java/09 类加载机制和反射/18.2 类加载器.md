## 18.2.1 类加载器简介
类加载器负责将所有类加载到内存中，并为之生成一个java.lang.Class对象。

JVM中，一个类用其全限定类名和其类加载器作为唯一标识

JVM启动时，形成三个类加载器组成的初始类加载器层次结构
1. Bootstrap ClassLoader:根类加载器/引导类加载器，负责加载Java核心类，由JVM自身实现，而非ClassLoader的子类。
2. Extension ClassLoader:扩展类加载器，负责加载JRE的扩展目录%JAVA_HOME%/jre/lib/ext中JAR包的类
3. System ClassLoader:系统/应用类加载器，负责在JVM启动时加载来自java命令的-classpath选项、java.class.path系统属性、CLASSPATH环境变量所指定的JAR包和类路径。

## 18.2.2 类加载机制
1. 全盘负责:当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其它Class也由该类加载器负责载入，除非显式使用另一个类加载器来载入
2. 父类委托:先让(父)类加载器试图加载该Class，若无法加载时才尝试从自己的类路径中加载该类
3. 缓存机制:保证所有加载过的Class都被缓存，当程序需要使用某个Class时，类加载器先从缓存区中搜寻该Class,若不存在，系统才读取该类对应的二进制数据并将其转换成Class对象存入缓存区中。
    - 因此修改了Class后，必须重新启动JVM才能生效

类加载器的父子关系:用户类加载器->系统类加载器->扩展类加载器->根类加载器。
- JVM的根类加载器不是Java实现的，没有继承ClassLoader抽象类，所以试图获取扩展类加载器的parent时返回null

类加载器加载类的8个步骤:
1. 检测此Class是否载入过[即缓存中是否存在]，若有则直接进入第8步。
2. 若父类加载器不存在[要么parent是根类加载器，要么本身是根类加载器]，则跳到第4步;若存在则继续执行
3. 请求父类加载器去载入目标类，若成功则进入第8步，否则执行第5步
4. 请求根类加载器来载入目标类，若成功则进入第8步，否则执行第7步
5. 当前类加载器尝试寻找Class文件[从ClassLoader相关的类路径中寻找]，若找到则执行第6步，否则第7步
6. 从文件中载入Class，成功载入则进入第8步
7. 抛出ClassNotFoundException异常
8. 返回对应的java.lang.Class对象
- 其中第5、6步允许重写ClassLoader的finClass方法来实现自己的载入策略或重写loadClass方法实现自己的载入过程

## 18.2.3 创建并使用自定义的类加载器
JVM中除了根类加载器之外的所有类加载器都是ClassLoader子类的实例，开发者可以通过继承ClassLoader子类来实现自定义的类加载器。
- loadClass(String name,boolean resolve):ClassLoader的入口点，根据指定名称加载类，系统就是调用该方法来获取指定类对应的Class对象
- findClass(String name):根据指定名称查找类
- final Class defineClass(String name,byte[] b,int off,int len):负责将指定类的字节码文件读入字节数组中，并转换成Class对象。 

loadClass()方法的执行步骤:
1. 用findLoadedClass(String name)来检查是否已经加载类，若已加载则直接返回
2. 在父类加载器上调用loadClass方法，若父类加载器为null，则使用根类加载器来加载
3. 调用findClass方法查找类

因此，通常推荐重写findClass方法来实现自定义的ClassLoader，避免覆盖默认类加载器的父类委托、缓存机制两种策略。

使用自定义的类加载器，可以实现以下功能:
- 执行代码前自动验证数字签名
- 根据用户提供的密码解密代码，实现代码混淆器来避免反编译*.class文件
- 根据用户需求动态地加载类
- 根据应用需求把其它数据以字节码的形式加载到应用中

## 18.2.4 URLClassLoader类
ClassLoader的实现类URLClassLoader是系统类加载器和扩展类加载器的父类[继承关系]，可以从本地文件系统/远程主机互殴去二进制文件来加载类

示例:直接从文件系统中加载MySQL驱动，无须将其添加到CLASSPATH环境变量中


