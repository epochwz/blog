**垃圾回收\(Garbage Collection,GC\)：**一种动态存储管理技术，按照特定的**垃圾回收算法**实现内存资源的自动释放和回收功能

Java 的JRE使用一个后台线程在后台自动进行Java程序内存的分配和回收，称为**垃圾回收机制**

JVM 的堆内存是一个运行时数据区，用于保存类的对象，这些对象所占用的内存不需要程序通过代码来显式的释放，而是由Java的垃圾回收器依照特定的垃圾回收算法自动进行

垃圾回收除了回收垃圾对象外，还能整理内存碎片

垃圾回收具有不可预知性，即使通过System.gc\(\)等方法来建议系统进行垃圾回收，依然无法精确控制

* 方法执行时会创建自己的内存栈，方法结束时该栈被销毁。局部变量都放在栈中。
* 创建对象时，对象被保存到运行时数据区，即堆内存，堆内存中的对象不随方法结束而销毁。
* 只有当一个对象没有任何引用变量引用它时，系统的垃圾回收器才会回收它。

Java 程序的内存分配和回收由 JRE 在后台自动进行。JRE 负责回收不再使用的内存，称为垃圾回收。

* JRE 提供一个后台线程来进行检测和控制，一般在CPU空闲或内存不足时进行垃圾回收，程序员无法精准控制

垃圾回收算法基本任务：发现无用对象，回收其所占空间，供程序再次使用

垃圾回收特点：

* 目标是回收无用对象的内存空间\[JVM 堆内存中的内存空间\]，只能回收内存资源，而非其他物理资源\[数据库连接，磁盘IO\]
* 可以通过将对象的引用变量设置为null,暗示该对象可以回收
* 垃圾回收发生的不可预知性。采用不同垃圾回收机制和算法。程序员仅可以通过gc\(\)方法建议系统回收，仍无法精确控制
* 垃圾回收精确性两方面：
  * 能精确标记活着的对象：完全回收废弃对象的前提，否则可能造成内存泄露
  * 能精确定位对象之间的引用关系：实现归并和复制等算法的必要条件，保证所有对象被可靠回收，所有对象能被重新分配，减少内存碎片的产生

垃圾回收实现方式：垃圾回收开始就停止程序的运行、垃圾回收运行时允许程序的线程运行、同一时间允许垃圾回收多线程运行

编写Java程序的原则：对于不再需要的对象，不要引用它们。

Java8 删除了永生代内存\[用以存储一些需要常驻内存，不被垃圾回收的信息\]，改为使用本地内存来存储类的元数据信息，称之为 元空间。

定义

* 当程序创建对象、数组等引用类型实体时，系统会在堆内存中为之分配一块内存区，对象就保存在这块内存区中。
* 当这块内存不再被任何引用变量引用时，这块内存就变成了垃圾，等待垃圾回收机制进行回收。

特征

* 垃圾回收机制只负责回收堆内存中的对象，不会回收任何物理资源\[数据库连接、网络IO等资源\]
* 程序无法精确控制垃圾回收的运行，垃圾回收会在合适的时候进行\[当对象永久性地失去引用后，系统会在合适地时候回收它所占地内存\]
* 在垃圾回收机制回收任何对象之前，总会先调用它的finalize\(\)方法，该方法可能导致该对象重新复活\[让一个引用变量重新引用该对象\],从而导致取消回收。

## 6.10.1 对象在内存中的状态

当一个对象在堆内存中运行时，根据它被引用变量所引用的状态，可以分为三种:

* 可达状态：对象被创建后，有一个以上的引用变量引用它，则该对象在程序中处于可达状态，程序可通过引用变量调用其实例变量和方法
* 可恢复状态：程序中某个对象不再有任何变量引用它，则进入可恢复状态，系统的垃圾回收机制准备回收该对象所占用的内存。回收该对象前，系统在调用finalize\(\)方法时重新让一个引用变量引用该对象，进入可达状态，否则进入不可达状态。
* 不可达状态：当对象所有引用变量的关联都被切断，且系统已经调用所有对象的finalize\(\)方法后依然没有使该对象变成可达状态，则该对象将永久性失去引用，变成不可达状态，此时系统准备真正回收该对象所占有的资源。  
  \`\`\`java  
  package jwz;

// 对象的状态转换  
public class StatusTranfer{  
    public static void test\(\){  
        String a = new String\("轻量级Java EE企业应用实战"\); //①  
        a = new String\("疯狂Java讲义"\);   //②  
    }  
    public static void main\(String\[\] args\){  
        test\(\);     //③  
    }  
    // 执行①后，"轻量级……"字符串对象处于可达状态  
    // 执行②后，"轻量级……"字符串对象处于可恢复状态，而"疯狂Java讲义"字符串对象处于可达状态  
    // 一个对象可以被一个方法的局部变量引用，也可以被其他类的类变量引用，或被其他对象的实例变量引用。  
    // 当某个对象被其他类的类变量引用时，只有该类被销毁后，该对象才会进入可恢复状态；  
    // 当某个对象被其他对象的实例变量引用时，只有当该对象被销毁后，该对象才会进入可恢复状态。  
}

    ## 6.10.2 强制垃圾回收
    当对象失去引用后系统何时调用它的finalize方法对其进行资源清理，它何时变成不可达状态，系统何时回收其占用的内存，对于程序完全透明。

    程序只能控制一个对象何时不再被引用，绝不能控制它何时被回收。

    程序无法精确控制Java垃圾回收的时机，但可以强制[建议]系统进行垃圾回收----通知系统进行垃圾回收，但系统是否立即进行回收依然不确定。

    强制系统垃圾回收的两种方式
    - System.gc()
    - Runtime.getRuntime().gc();

    查看每次垃圾回收后的提示信息`java -verbose:gc 类名`
    ```java
    package jwz;

    // 强制垃圾回收
    public class GcTest{
        public static void main(String[] args){
            for (int i = 0 ; i < 4; i++){
                // 创建对象后没有变量引用，立即进入可恢复状态等待系统回收，但直到程序退出，系统依然不会回收该资源
                new GcTest();
                // 下面两行代码的作用完全相同，强制系统进行垃圾回收，此时程序结束前可以看到系统回收该资源
                // System.gc();
                // Runtime.getRuntime().gc();
            }
        }
        public void finalize(){
            System.out.println("系统正在清理GcTest对象的资源...");
        }
    }

## 6.10.3 finalize 方法

* 垃圾回收机制回收某个对象所占用的内存之前，通常要求程序调用适当的方法清理资源。
* 没有明确指定清理资源的情况下，java提供了默认机制来清理该对象的资源  
  Object类的实例方法，任何java类可重写：protected void finalize\(\) throws Throwable

  当finalize方法返回后，对象消失，垃圾回收机制开始执行

* 只有程序认为需要更多的额外内存时，垃圾回收机制才会进行垃圾回收。如果程序终止之前始终没有进行垃圾回收，则不会调用失去引用对象的finalize方法来清理资源。

finalize方法特点：

* 永远不要主动调用某个对象的finalize方法，该方法应交给垃圾回收机制调用
* 该方法何时被调用，是否被调用 具有不确定性，不能当成一定会被执行的方法。
* 当JVM执行可恢复对象的finalize方法时，可能使该对象或系统中的其他对象重新变成可达状态
* 当JVM执行该方法时出现异常，垃圾回收机制不会报告异常，程序继续执行

由于finalize方法不一定总被执行，因此如果想清理某个类里打开的资源，则不要放在finalize方法中进行清理。

```java
package jwz;

// finalize方法复活对象，展示垃圾回收的不确定性
public class FinalizeTest{
    private static FinalizeTest ft = null;
    public void info(){
        System.out.println("测试资源清理的finalize方法");
    }
    public static void main(String[] args) throws Exception{
        // 创建FinalizeTest对象立即进入可恢复状态
        new FinalizeTest();

        // 通知系统进行资源回收
        System.gc();  //①

    // 两种方式强制垃圾回收机制调用可恢复对象的finalize()方法
        // Runtime.getRuntime().runFinalization();   //②
        System.runFinalization();   //③

        // 若垃圾回收机制调用了finalize方法则运行正常，否则空指针异常
        ft.info();
    }
    public void finalize(){
        // 让ft引用试图回收的可恢复对象，即试图让可恢复对象重新变成可达
        ft = this;
    }
}
```

## 6.10.4 对象的软、弱、虚引用

java中对 对象 的引用有4种方式：  
1. 强引用：被一个以上引用变量引用  
    通过引用变量来操作实际的对象,该对象处于可达状态，不可能被回收.最常见的引用方式。  
2. 软引用：通过SoftReference类来实现  
    当系统内存空间足够时，不会被系统回收，程序可使用该对象；当内存空间不足时，系统可能会回收它。通常用于对内存敏感的程序中。  
3. 弱引用：通过WeakReference类来实现  
    类似软引用，但引用级别更低。当系统垃圾回收机制运行时，不管系统内存是否足够，总会回收该对象的内存。

```java
    package jwz;

    import java.lang.ref.*;

    // 弱引用所引用对象被系统垃圾回收的过程
    public class ReferenceTest{
        public static void main(String[] args) throws Exception{
            // 将看不到运行效果，因为系统会使用常量池来管理字符串直接量，即使用强引用来引用它，系统不会回收该字符串直接量
            // String str="疯狂Java讲义";
            // 创建一个字符串对象，可达状态
            String str = new String("疯狂Java讲义");
            // 创建一个弱引用，让此弱引用引用到"疯狂Java讲义"字符串
            WeakReference wr = new WeakReference(str);  //①
            // 切断str引用和"疯狂Java讲义"字符串之间的引用
            str = null;   //②
            // 取出弱引用所引用的对象
            System.out.println(wr.get());  //③
            // 强制垃圾回收
            System.gc();
            System.runFinalization();
            // 再次取出弱引用所引用的对象
            System.out.println(wr.get());  //④
        }
    }
```

1. 虚引用:通过PhantomReference类实现
    类似于没有引用。主要用于跟踪对象被垃圾回收的状态。不能单独使用，必须和引用队列联合使用。
   上面三个引用类都有get\(\)方法用于获取被它们所引用的对象

引用队列

* 由java.lang.ref.ReferenceQueue类 表示，用于保存被回收后对象的引用。
* 联合使用软引用、弱引用和引用队列时，系统在回收被引用的对象后把被回收对象对应的引用添加到关联的引用队列中。
* 虚引用在对象被释放之前，就将把它对应的虚引用添加到它关联的引用队列中，使得可以在对象被回收之前采取行动。
* 虚引用主要作用是跟踪对象被垃圾回收的状态，程序可以通过检测与虚引用关联的引用队列中是否包含了该虚引用，从而了解虚引用所引用的对象是否即将被回收。
* 虚引用不能单独使用，没有意义。

  ```java
    package jwz;

    import java.lang.ref.*;

    public class PhantomReferenceTest{
        public static void main(String[] args) throws Exception{
            // 创建一个字符串对象
            String str = new String("疯狂Java讲义");
            // 创建一个引用队列
            ReferenceQueue rq = new ReferenceQueue();
            // 创建一个虚引用，让此虚引用引用到"疯狂Java讲义"字符串并添加到引用队列
            PhantomReference pr = new PhantomReference (str , rq);
            // 切断str引用和"疯狂Java讲义"字符串之间的引用
            str = null;
            // 取出虚引用所引用的对象，系统并不能通过虚引用获取被引用的对象，所以此处输出null
            System.out.println(pr.get());  //①
            // 取出引用队列中最先进入队列中的引用与pr进行比较，此时被虚引用引用的对象尚未被回收，也就不在队列中，false
            System.out.println(rq.poll() == pr);   //②
            // 强制垃圾回收
            System.gc();
            System.runFinalization();
            // 垃圾回收之后，虚引用将被放入引用队列中，取出引用队列中最先进入队列中的引用与pr进行比较，true
            System.out.println(rq.poll() == pr);   //②
        }
    }
  ```

由于垃圾回收不确定性，当程序希望从软、弱引用中取出被引用对象时，该对象可能已经被释放了。  
如果程序希望使用该被引用对象，则必须重新创建该对象。  
\`\`\`java  
// 取出弱引用所引用的对象  
obj=wr.get\(\);  
// 如果取出的对象为null  
if\(obj==null\){  
    // 重新创建一个新的对象，并使用强引用来引用它  
    obj=recreateIt\(\);  
    // 取出弱引用所引用的对象，并赋值给obj变量  
    wr=new WeakReference\(obj\);  
}  
// 操作obj对象  
obj=null;// 再次切断obj和对象之间的关联

