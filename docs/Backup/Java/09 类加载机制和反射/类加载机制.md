# 类加载机制

使用`java`命令运行某个 Java 程序时，将启动一个独立的 Java 虚拟机进程，不同进程的 Java 程序互不干扰

该程序所有的线程、变量都处于该进程的内存区中，直到该进程终止。

JVM 进程终止的几种情况

- 程序运行到最后正常结束
- 程序运行到 `System.exit()` 或 `Runtime.getRuntime().exit()` 代码处结束
- 程序执行过程中遇到未捕获的异常或错误时结束
- 程序所在平台强制结束该 JVM 进程

## 类加载

当程序第一次使用某个类时，如果该类尚未被加载到内存中，则系统会通过**加载、连接、初始化**三个连续的步骤对该类进行初始化，统称**类加载 / 类初始化**

### 类的加载

类的加载指的是程序将类的 class 文件读入内存，并为之创建一个 `java.lang.Class` 对象的过程。

- Java 程序中所有的类都是 `java.lang.Class` 的实例，因此程序中使用任何类时，都会为之创建一个 `java.lang.Class` 对象

类的加载由类加载器 (ClassLoader) 完成，JVM 提供的类加载器通常称为系统类加载器，开发者可以通过继承 `java.lang.ClassLoader` 创建自己的类加载器

类加载器可以从以下几种来源加载 class 文件

- 本地系统
- Jar 包，如 JDBC 的数据库驱动类
- 网络
- 动态编译 Java 源文件，并执行加载

JVM规范允许系统预先加载某些类，而不一定要等到“首次使用”该类的时候

### 类的连接

完成类的加载后，就进入了类的连接阶段，负责把类的二进制数据合并到JRE中，具体分为以下三个步骤

1. 验证：检验被加载的类是否有正确的内部结构，并和其他类协调一致
2. 准备：负责为类变量分配内存空间，并执行默认初始化
3. 解析：将类的二进制数据中的符号引用替换成直接引用

### 类的初始化

按代码顺序初始化类变量，如果没有指定初始值，则使用变量类型对应的默认初始值

- 在声明类变量时指定初始值
- 在静态初始化块中指定初始值

JVM初始化一个类的步骤

1. 如果这个类还没有被加载和连接，则先加载、连接该类
2. 如果该类的父类还没有被初始化，则先初始化其直接父类
3. 如果类中有初始化语句，则依次执行这些初始化语句

在步骤2中对其直接父类的初始化也遵循这三个步骤，直至顶级父类`java.lang.Object`

当程序通过以下6种方式使用某个类/接口时，系统会初始化该类/接口

- 创建类的实例：构造器、反射、反序列化
- 访问类方法
- 访问类变量：调用、赋值
- 使用反射创建类/接口的 `java.lang.Class` 对象,如 `Class.forName(className)`
- 初始化某个类的子类
- 直接使用 `java` 命令运行某个主类

- 访问类的“宏变量”（变量值可以在编译器确定的final变量）不会导致类的初始化
- `Class.loadClass(class)` 仅仅是加载类，不会导致类的初始化

## 类加载器

类加载器负责类的加载：通过类的全限定名称获取其二进制字节流并读入内存中，将字节流所代表的静态存储结构转化成方法区的运行时数据结构，并在Java堆中生成一个代表该类的 `java.lang.Class` 对象，作为方法区中这些数据的访问入口

在JVM中，一个类的唯一标识是 类加载器+全限定类名

1. Bootstrap ClassLoader: 根类加载器,由JVM自身实现，不是`java.lang.ClassLoader`的子类,负责加载Java的核心类`%JAVA_HOME%/jre/lib/*.jar`。当执行java.exe时，使用-Xbootclasspath或-D选项指定sum.boot.class.path系统属性值可以指定加载附加的类
2. Extension ClassLoader: 扩展类加载器,负责加载JRE的扩展目录`%JAVA_HOME%/jre/lib/ext`
3. System ClassLoader: 系统类加载器,也称应用加载器(AppClassLoader),负责在JVM启动时加载来自java命令的-classpath选项、java.class.path系统属性、CLASSPATH环境变量所指定的JAR包和类路径.如果没有特别指定，开发者自定义的类加载器都以系统类加载器作为父加载器

JVM类加载器的层次结构：根类加载器->扩展类加载器->系统类加载器->开发者自定义类加载器

JVM的类加载机制

- 全盘负责：当一个类加载器负责加载某个class时，该class所依赖和引用的其他class也将由该类加载器负责加载，除非显式使用另外一个类加载器来加载
- 父类委托：先让父类加载器尝试加载该Class，仅当父类加载器无法加载该类时才尝试从自己的类路径中加载该类
- 缓存机制：保证所有被加载过的Class会被缓存，仅当缓存区中不存在该Class时，才会读取该类的二进制数据并加载

类加载全过程

1. 检查该Class是否加载过，如果有则直接进入第8步
2. 如果父类加载器不存在（要么其parent是根类加载器，要么其本身是根类加载器），则进入第4步
3. 使用父类加载器加载目标类，成功则进入第8步，否则执行第5步
4. 使用根类加载器加载目标类，成功这进入第8步，否则进入第7步
5. 当前类加载器尝试寻找Class文件，找到则进入第6步，否则进入第7步
6. 从文件中载入Class，成功后进入第8步
7. 抛出ClassNotFountException
8. 返回对应的`java.lang.Class`对象

开发者可以重写ClassLoader的findClass()/loadClass()在第5、6步中实现自己的类加载过程

JVM中除了根类加载器之外的所有类加载器都是ClassLoader子类的实例,开发者可以通过扩展ClassLoader的子类来实现自定义的类加载器