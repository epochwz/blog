系统可能在第一次使用某个类时加载该类，也可能采用预加载机制来加载某个类
## 18.1.1 JVM和类
当使用java命令运行某个程序时，该命令将启动一个Java虚拟机进程，该Java程序所有活动[线程、所有变量]都处于该进程中，使用该进程的内存区。

当系统出现以下情况时，JVM进程终止:
1. 程序正常执行到结束
2. 程序执行到System.exit()或Runtime.getRuntime().exit()时结束
3. 程序执行时遇到未捕获的异常或错误而结束
4. 程序所在平台强制结束JVM进程

JVM进程终止后，该进程在内存中的状态丢失:
```java
class A{
    // 定义该类的类变量
    public static int a = 6;
}

class ATest1{
    public static void main(String[] args){
        // A类的a变量+1后输出，a=7;
        System.out.println(++A.a);
    }
}

class ATest2{
    public static void main(String[] args){
        // 运行ATest1后A.a=?
        System.out.println(A.a);
    }
}
```
结论:ATest1和ATest2分别运行时，处于不同的JVM进程，数据不共享。

## 18.1.2 类的加载
当程序主动使用某个类时，若该类还未被加载到内存中，则系统通过加载、连接、初始化三个步骤对该类进行初始化,统称类初始化或类加载

加载:程序使用任何类时，都会将其.class文件读入内存，为之创建java.lang.Class对象[Java中任何类都是java.lang.Class的实例，即类也是对象，万物皆对象]

类的加载由类加载器完成:JVM提供的类加载器称为系统类加载器，开发者可以通过继承ClassLoader基类创建自己的类加载器

不同的类加载器可以从不同来源加载类的二进制数据:
1. 从本地文件系统加载class文件
2. 从JAR包加载class文件
3. 从网络加载class文件
4. 把一个Java源文件动态编译，并执行加载

类加载器无须等待"首次使用"该类时才加载该类，JVM规范允许系统预先加载某些类。

## 18.1.3 类的连接
类加载后生成对应的Class对象，进入连接阶段，负责将类的二进制数据合并到JRE中，分为如下阶段:
1. 验证:验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致
2. 准备:类准备阶段负责为类的类变量分配内存，并设置默认值
3. 解析:将类的二进制数据中的符号引用替换成直接引用

## 18.1.4 类的初始化
在类的初始化阶段，JVM负责对类进行初始化，主要对类变量进行初始化
- 声明类变量时指定初始值
- 类初始化块中指定初始值
- 系统分配默认值

JVM初始化一个类的步骤:
1. 加载和连接
2. 若其直接父类尚未初始化，则初始化其直接父类[上溯至Object类]
3. 依次执行初始化语句[声明变量时指定初始值，类初始化块]

## 18.1.5 类初始化的时机
Java程序首次使用下面6种方式来使用接口/类时，系统对其进行初始化:
1. 创建类的实例[new、反射、反序列化]
2. 调用其类方法
3. 访问其类变量，或为其类变量赋值
4. 使用反射来强制创建某个类/接口对应的Class对象[Class.forName("Person")]
    - 若系统尚未初始化Person类，则该行代码导致Person类被初始化，并返回Person类对应的Class对象
5. 初始化某个类的子类时，其所有父类都会被初始化
6. 直接使用java命令运行某个主类，程序会先初始化该主类

声明final类变量时指定初始值，则相当于"宏变量"，系统会将程序中使用到该变量的地方直接替换成它的值[相当于直接量]，因此即使程序使用该final类变量，也不会导致该类被初始化。
```java
package jwz;

class MyTest{
	static{
		System.out.println("静态初始化块...");
	}
	// 定义 相当于“宏变量”的final类变量
	static final String compileConstant = "疯狂Java讲义";
	// 定义 不相当于“宏变量”的final类变量
	// 该变量的值必须在运行时确定，因此调用该变量必须保留对MyTest的引用，导致该类被初始化
	// static final String compileConstant = System.currentTimeMillis()+"";
}

public class CompileConstantTest{
	public static void main(String[] args){
		// 访问、输出MyTest中的compileConstant类变量
		// 编译后相当于使用直接量"疯狂Java讲义"，而与MyTest.compileConstant无关，不会初始化MyTest类
		System.out.println(MyTest.compileConstant);   // ①
	}
}
```

ClassLoader.loadClass(package.ClassName)方法仅仅是加载类，不会对加载的类进行初始化
Class.forName(package.ClassName)才会对该类进行初始化
```java
package jwz;

class Tester{
	static{
		System.out.println("Tester类的静态初始化块...");
	}
}
public class ClassLoaderTest{
	public static void main(String[] args) throws ClassNotFoundException{
		ClassLoader cl = ClassLoader.getSystemClassLoader();
		// 下面语句仅仅是加载Tester类
        cl.loadClass("jwz.Tester");
        System.out.println("系统加载Tester类");
        // 下面语句才会初始化Tester类
        Class.forName("jwz.Tester");
    }
}
```