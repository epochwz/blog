## 13.6.1 事务的概念和MySQL事务支持
事务：由 一步或几步数据库操作序列 组成的逻辑执行单元，要么全部执行，要么放弃执行，是保证底层数据完整的重要手段.一段程序通常包含多个事务。

事务的特性ACID：
- 原子性Atomicity:事务是应用中不可再分的最小逻辑执行体，
- 一致性Consistency:事务执行的结果必须使数据库从 一致性状态A 变成 一致性状态B
- 隔离性Isolation:各个事务的执行互不干扰，其内部操作和其它并发事务是隔离的。
- 持续性Durability:也称持久性，指事务一旦提交，对数据的改变将记录到永久存储器中，通常是保存进物理数据库

数据库事务由以下语句组成:
- 一组DML语句，经过这组DML语句修改后的数据将保持良好的一致性
- 一条DDL/DCL语句，因为DDL/DCL语句会导致事务立即提交

当事务所包含的全部数据库操作都成功执行后，应该commit事务，使修改永久生效
- 显式提交：使用commit
- 自动提交：执行DDL/DCL语句或程序正常退出

当事务所包含的任意一个数据库操作执行失败后，应该rollback事务，使修改全部失效
- 显式回滚：使用rollback
- 自动回滚：系统错误或强行退出程序

MySQL默认关闭事务[即打开自动提交]。默认情况下，用户在cmd每执行一条DML语句，该语句都将被立即保存到数据库里。

开启MySQL的事务支持`SET AUTOCOMMIT = 0/1`0为关闭自动提交，即开启事务

一个命令行窗口相当于一次连接session，在该窗口开启事务不影响其它窗口，即其它窗口依旧为自动提交。

临时开启事务使用 `begin || start transaction` 命令，位于此命令后的DML语句不会立即生效，除非显式使用commit或执行DDL/DCL语句来提交事务。
```
# 临时开启事务
begin;
# 向数据库插入数据
insert into test_table values(10,"ss","ss");
insert into test_table values(11,"ss","ss");
insert into test_table values(12,"ss","ss");
# 查询插入结果,将看到插入成功。若在其它窗口查询，则看不到插入的数据，因为事务隔离且未提交
select * from test_table;
# 回滚事务
rollback;
# 再次查询，将看不到插入的数据.此时数据库已回滚到事务开始的状态
select * from test_table;
```

提交和回滚操作都会结束当前事务。

MySQL使用savepoint来设置事务中间点，使事务得以回滚到指定中间点，而不是回滚全部事务。回滚到指定中间点后依然处于当前事务之中，不会结束该事务。

## 13.6.2 JDBC的事务支持
JDBC连接的事务支持由Connection提供，默认关闭事务，即自动提交：每执行一条SQL语句，便立即提交到数据库，永久生效，无法回滚。

当Connectino遇到未处理的异常，系统将异常退出，事务会自动回滚。若捕获了异常，则需要在异常处理块中显式回滚事务。
```java
package jwz;

import java.sql.*;
import java.io.*;
import java.util.*;

public class TransactionTest{
	public static void main(String[] args){
		String[] sqls = new String[]{
			"insert into test_table values(18 , 'aaa' ,1)",
			"insert into test_table values(19 , 'bbb' ,1)",
			"insert into test_table values(20 , 'ccc' ,1)",
			// 违反主键约束，抛出SQL异常，事务自动回滚，插入数据无效
			// 若将该条语句注释掉，则事务正常完成，以上修改将被提交生效
			"insert into test_table values(20 , 'ccc' ,5)" 
		};

		try(
			Connection conn = ds.getConnection()
		){
			// 关闭自动提交，开启事务
			conn.setAutoCommit(false);
			// 查看当前Connection的事务是否打开
			System.out.println(conn.getAutoCommit());
			try(
				// 使用Connection来创建一个Statment对象
				Statement stmt = conn.createStatement()
			){
				// 循环多次执行SQL语句
				for (String sql : sqls){
					stmt.executeUpdate(sql);
				}
			}
			// 提交事务
			conn.commit();
		}catch (SQLException e) {
			System.out.println("数据库异常");
		}
	}
}
```

## 批量更新
JDBC提供批量更新功能，多条SQL语句将被作为一批操作同时收集，同时提交。

通过DatabaseMetaData的supportsBatchUpdates()方法来查看底层数据库是否支持批量更新

创建Statement对象，调用其addBatch()方法收集多条SQL语句，再调用long[] executeBatch()方法同时执行这些SQL语句,返回每条语句返回的long值组成的数组
- 若批量操作的语句中有一条语句的影响记录条数超过Integer.MAX_VALUE，则应该使用executeLargeBatch()方法
- 若在批量更新语句中添加了select查询语句将导致程序错误

批量更新操作被视为单个事务，若操作失败则全部回滚。
```java
// 保存当前事务状态
boolean autoCommit=conn.getAutoCommit();
// 关闭自动提交，开启事务
conn.setAutoCommit(false);
// 创建Statement对象
Statement stmt=conn.createStatement();
// 收集多条SQL语句
stmt.addBatch(sql1);
stmt.addBatch(sql1);
stmt.addBatch(sql1);
// 批量执行
stmt.executeLargeBatch();
// 提交事务
conn.commit();
// 恢复原本的事务状态
conn.setAutoCommit(autoCommit);
```

