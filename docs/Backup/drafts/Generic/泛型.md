# 泛型 (Generics)

Java 新手在刚开始接触泛型的时候，可能会感觉到有点困难。但事实上，在语法层面上使用泛型是十分简单的，而真正的困难在于理解为什么需要使用泛型，什么时候需要使用泛型。因此本文先通过一个简单的小例子来解释泛型存在的意义，再来详细介绍如何使用泛型。

## 为什么使用泛型

模拟这样一个场景：在一个动物园里有许多的笼子，用来饲养不同的小动物，我们可以往笼子里添加小动物，也可以从笼子里取出小动物。但是每个笼子只能装同一种动物（关了狗的笼子就不能再放鸟进去了）

根据需求，可以写出代码方案一：

```java
// 定义动物类
class Dog {
    public void run() { System.out.println("狗会跑"); }
}

class Bird {
    public void fly() { System.out.println("鸟会飞"); }
}

// 定义鸟笼 BirdCage
class BirdCage{
    private Bird[] birds=new Bird[10];
    private int size=0;
    public BirdCage(Bird...birds){
        for(Bird bird:birds){
            add(bird);
        }
    }
    public void add(Bird bird){
        birds[size++]=bird;
    }
    public Bird get(int index){
        return birds[index];
    }
}

// 定义狗笼 DogCage, 同 BirdCage，省略。.....

// 定义动物园类（测试类）
public class Zoo {
    public static void main(String[] args) {
        useConcreteCage();
    }

    // 使用具体的笼子类进行测试
    private static void useConcreteCage(){
        // 创建鸟笼并放入一只鸟
        BirdCage birdCage = new BirdCage(new Bird());
        // 取出第一只鸟，让它飞
        birdCage.get(0).fly();

        // 创建狗笼并放入一只狗
        DogCage dogCage = new DogCage(new Dog());
        // 取出第一只狗，让它跑
        dogCage.get(0).run();

        // 试图在狗笼里放入一只鸟，编译不通过，符合我们的预期
        // dogCage.add(new Bird());
    }
}
```

在方案一中，我们使用了最原始的方式，为每一种动物定义各自的笼子，显然可以很好的实现各种动物的存取功能；但是，如果这时候还有十种动物甚至更多，那就会产生类爆炸了。

在这个场景里，笼子其实相当于一个“**容器**”，仅仅是用来**存**/**取**动物的而已。所以我们希望定义一种笼子，可以存取各种类型的动物。

显然，我们可以用 Object 类来实现这种可以容纳各种动物类型的笼子，方案二代码如下：

```java
// 使用 Object 作为通用父类实现通用的笼子类
class ObjectCage {
    private Object[] animals = new Object[10];
    private int size = 0;

    public ObjectCage(Object... animals) {
        for (Object animal : animals) {
            add(animal);
        }
    }

    public void add(Object animal) {
        animals[size++] = animal;
    }

    public Object get(int index) {
        return animals[index];
    }
}

// 定义动物园类
public class Zoo {
    public static void main(String[] args) {
        // useConcreteCage();
        useObjectCage();
    }

    // 使用基于 Object 实现的通用笼子类进行测试
    private static void useObjectCage() {
        // Bird 放进笼子后变成了 Object 类型
        ObjectCage birdCage = new ObjectCage(new Bird());
        // 将鸟从笼子中取出时，必须强制类型转换成 Bird 类型，才能调用其专属的方法 fly()
        ((Bird) birdCage.get(0)).fly();

        ObjectCage dogCage = new ObjectCage(new Dog());
        ((Dog) dogCage.get(0)).run();

        // 试图在狗笼里放入一只鸟，编译居然通过，不符合我们的预期！！！
        dogCage.add(new Bird());
        // 将“狗”从笼子里取出，并强制类型转换成 Dog 类型后，调用其专属方法 run()；其实际类型是 Bird, 将导致运行时产生 ClassCastException
        ((Dog) dogCage.get(1)).run();
    }
}
```

在方案二中，虽然通过 Object 类可以实现容纳任意类型动物的笼子，但是，当我们将动物放入笼子后，动物的种类信息将被丢弃，所有的动物都变成了 Object 类型。这会导致什么呢？

1. 当我们取出动物时，需要进行强制类型转换 `Bird bird=(Bird) birdCage.get(0);` , 才能得到我们期望的动物类型，十分繁琐
2. 强制类型转换是从 Object 向下转型成其子类，可能导致 `ClassCastException`, 而这种异常只有在运行时才会被发现，给代码留下了安全隐患

可见，要通过 Object 类实现一个能够容纳**任意数据类型**的**容器**是很不优雅且存在安全隐患的；所以，我们希望能定义一个容器，实现以下的功能

1. 可以容纳任意的数据类型
2. 使用的时候可以指定容器具体的数据类型，操作容器的时候就不需要进行强制类型转换了
3. 如果往容器里放入跟指定类型不一致的数据，在编译期间就会报错，避免运行时产生 `ClassCastException`

要实现这种“容器”，就是我们“泛型”闪亮登场的时候了，方案三代码如下：

```java
// 定义基于泛型实现的通用笼子类
// 1. 在定义类的时候，声明“类型形参 T”, 它可以代表任意的数据类型 (String,Integer,Bird,Dog)
// 2. 在声明了“类型形参”的类 / 接口中，可以将形参 T 当成一种普通的数据类型，用来声明变量、作为返回值等
class GenericCage<T> {
    // 这里需要特别注意，形参 T 无法声明数组，只能先定义 Object 数组再进行类型转换
    private T[] animals = (T[]) new Object[10];
    private int size = 0;

    public GenericCage(T... animals) {
        for (T animal : animals) {
            add(animal);
        }
    }

    // T 作为一种数据类型来定义变量
    public void add(T animal) {
        animals[size++] = animal;
    }

    // T 作为一种数据类型来作为返回值
    public T get(int index) {
        return animals[index];
    }
}

// 定义动物园类
public class Zoo {
    public static void main(String[] args) {
        // useConcreteCage();
        // useObjectCage();
        useGenericCage();
    }

    // 使用基于泛型实现的通用笼子类进行测试
    private static void useGenericCage() {
        // 创建笼子的时候指定动物的种类是鸟，此时 T 相当于数据类型 Bird
        GenericCage<Bird> birdCage = new GenericCage<>(new Bird());
        // 泛型笼子能够记住动物的种类是 Bird, 因此取出的时候无需进行强制类型转换
        birdCage.get(0).fly();

        // 创建笼子的时候指定动物的种类是狗，此时 T 相当于数据类型 Dog
        GenericCage<Dog> dogCage = new GenericCage<>(new Dog());
        dogCage.get(0).run();

        // 试图在狗笼里放入一只鸟，编译不通过，符合我们的预期
        // dogCage.add(new Bird());
    }
}
```

在方案三中，我们定义了一个“泛型类” `GenericCage`，也就是一个“支持任意数据类型的类”，这是泛型的一个简单的典型用法。实现的代码很简单，通过注释基本可以理解泛型是如何定义和使用的。

在测试类 `Zoo` 中，我们可以看到，使用泛型类的时候，可以指定泛型类的类型 `GenericCage<Dog>` ，这样我们的“笼子”就能记住动物的类型，在取出的时候无需再进行强制类型转换，也无法放入不同类型的动物，在代码的编译期就保证了类型安全。

通过这个小例子，我们可以看出，之所以使用泛型，是为了

- 允许程序定义支持任意数据类型的类 / 接口 / 方法
- 优雅：消除丑陋的强制类型转换，提高代码的可读性（使用时指定了期望的数据类型，所见即所得）
- 安全：在编译期检查并保证数据类型的安全，避免运行时发生 `ClassCastException`，符合 *越早出错代价越小* 原则
- 性能
  - 泛型是在编译期进行检查，因此支持泛型无需修改 JVM 或类文件
  - 编译器生成的代码跟不使用泛型和强制类型转换时所写的代码几乎一致，但更能确保类型安全

当然，这个例子可能还不完全能够体现泛型的优势，在后文介绍完泛型的基本用法之后，我们将看到一些更为实用和优雅的泛型案例

## 什么是泛型

泛型是 JDK1.5 之后引入的“**参数化类型 (Parameterized Type)**”, 允许将“引用型的数据类型”当成类似方法的参数一样来传递，这种参数化体现在以下三个方面

1. 允许程序在定义类、接口、方法时声明 “**类型形参**”
2. 允许程序在声明了“类型形参”的类、接口、方法中，将这个类型形参当成具体的数据类型来使用
3. 允许程序在声明类 / 接口的变量、使用构造器创建类对象、调用方法时传入 “**类型实参**”

泛型通过这种“类型参数”，将原本定义类和方法中的成员变量时就需要明确指定的数据类型推迟到创建对象或调用方法时才去指定，这样既能支持任意的数据类型，又消除了强制类型转换的繁琐操作，同时在编译期就能检查并保证数据类型的安全。

泛型的设计原则：只要在编译期没有出现“未经检查的转换 (Unchecked assignment)”的警告，那么运行时就不会出现 `ClassCastException`

## 如何使用泛型

### 泛型初体验

引入泛型概念后，JDK1.5 改写了集合框架中的全部接口和类，增加了泛型支持，我们可以通过传入类型实参来声明和创建任意数据类型的集合对象。

让我们以 List 为例，看看 JDK 中的集合接口 / 类是如何支持泛型的

```java
// 通过尖括号<E>声明一个类型形参 E
public interface List<E>{
    // 类型形参 E 可以当成普通类型使用，此处用于声明一个变量
    boolean add(E e);
    // ......
}
```

通过代码看出，实现泛型支持很简单

- 定义类 / 接口的时候声明了一个类型形参：`interface List<E>`
- 在泛型类 / 接口里面，将这个形参 E 当成普通的类型来使用：`E e;`

接下来再看一下，如何使用支持泛型的 List

```java
// 传入类型实参 String, 则该 List 只能保存 String 类型的元素
List<String> stringList=new ArrayList<String>();
stringList.add("Hello World");
// 编译报错
stringList.add(1024);

// 传入类型实参 Integer, 则该 List 只能保存 Integer 类型的元素
List<Integer> integerList=new ArrayList<>();
```

通过代码可以看出，使用支持泛型的类也很简单

- 声明类对象的变量：`List<String> stringList;`
- 调用构造器创建对象：`stringList=new ArrayList<String>();`

**菱形语法：** 在 JDK1.7 之后，调用泛型类的构造器创建对象时，只需要保留`<>`即可，代码如下：

```java
List<String> stringList=new ArrayList<>();
```

### 泛型类 / 接口

#### 定义泛型类 / 接口

集合类 / 接口是泛型十分重要的使用场所，因此 JDK 默认为它们都实现了泛型支持，而我们也可以定义自己的**泛型类**。

事实上前文中我们已经定义了一个泛型类 `Zoo`, 这里通过实现一个可以存储**任意数据类型**元素的“容器”，再总结一下如何定义泛型类 / 接口

1. 在定义类 / 接口的时候**声明**“**类型形参**”：`class Container<T>`
2. 在泛型类中将类型形参 T 当成普通数据类型来使用：`T element;`
3. 在声明类对象的变量时**传入**“**类型实参**”：`Container<String> stringContainer;`

```java
// 1. 在定义类的时候，声明了一个类型形参 T；它代表了一种数据类型，可以是 String、Integer，也可以是开发者自定义的类
// 2. 在类的内部中，将 T 当成普通的数据类型来使用，可以用于声明变量，作为返回值等等
public class Container<T> {
    // T 作为一种数据类型，用于声明变量
    private T element;

    public Container(T element) {
        this.element = element;
    }

    // T 作为返回值的数据类型
    public T getElement(){
        return element;
    }

    public static void main(String[] args) {
        // 3. 在声明泛型类对象的变量的时候传入类型实参 String，此时 T 代表了 String 类型
        Container<String> stringContainer = new Container<>("Hello World");
        // 3. 在声明泛型类对象的变量的时候传入类型实参 String，此时 T 代表了 Integer 类型
        Container<Integer> integerContainer = new Container<>(999);
    }
}
```

#### 从泛型类派生子类

定义了泛型类 / 接口之后，可以为接口创建实现类，或从父类派生子类，此时这些泛型接口、泛型父类不能再包含“类型形参”，而应该传入“类型实参”

```java
// 错误，继承泛型类时必须传入类型实参
class A extends GenericCage<T>{}

// 正确，传入类型实参 String
class A extends GenericCage<String>{}
// 正确，不传入类型实参，则默认传入 Object 类
class A extends GenericCage{}
```

子类如果重写父类中使用了泛型形参的方法，其泛型形参 T 的具体类型应该是继承父类时传入的类型实参，示例如下：

```java
// 1. 继承父类时传入的类型形参是 "String" 类型
class A extends GenericCage<String> {
    @Override
    // 2. 父类的 类型形参 T 变成 String
    public void add(String animal) {
        super.add(animal);
    }
    @Override
    // 2. 父类的 类型形参 T 变成 String
    public String get(int index) {
        return super.get(index);
    }
}
```

**Tips:** 不存在泛型类，泛型只在编译期进行泛型检查，即`List<String>`和`List<Integer>`是同一个类，并不会生成新的 class 文件，在内存中也只占用同一块空间，因此泛型类中的静态成员不允许使用类型形参，instance 运算符后也不能使用泛型类

### 泛型方法

当一个类里面仅仅是一个方法需要支持任意数据类型时，可能我们没必要定义一个泛型类，而仅仅需要一个泛型方法。

定义泛型方法也很简单，只需要在声明方法的时候定义一个或多个类型形参

```java
修饰符 <T,S> 返回值类型 方法名（形参列表）{}
```

泛型方法允许类型形参被用来表示方法的一个或多个参数之间的类型依赖关系、或者方法返回值与参数之间的类型依赖关系，如果没有这样的依赖关系，就不应该使用泛型方法

### 泛型构造器

可以显式指定泛型构造器，此时不能使用菱形语法

## 设定类型形参上限

声明类型形参时可以指定类型形参的上限类型以及实现的接口 `class GenricClass<T extends Number & java.io.Serilizable>` Number 的子类且实现了 Serilizable 接口

## 擦除和转换

严格来讲，使用泛型类 / 接口时应该总是指定实际的类型参数，但由于在 JDK1.5 之前是没有泛型的，为了兼容旧代码，所以 Java 也允许在使用泛型类 / 接口的时候不指定实际的类型参数，此时类型参数的类型是其声明时的上限类型

```java
// 使用泛型类时指定实际的类型参数 Integer
List<Integer> intList=new ArrayList<>();
// 使用泛型类时不指定实际的类型参数，此时类型形参 T 是其声明时的第一个类型上限，此处即 Object
List list=new ArrayList();
```

当把一个具有泛型信息的对象赋给另一个没有泛型信息的变量时，泛型信息会被丢弃,称为 **类型擦除**

```java
// 具备泛型信息的对象
List<Integer> intList=new ArrayList<>();
// 不具备泛型信息的对象
List list;
// 类型擦除：intList 的类型参数是 Integer 这个信息在赋值给 list 时被擦除了，list 的类型参数依旧是其上限 Object
list=intList;
// 编译通过
Object element=container.getElement();
// 编译错误
// Integer element=container.getElement();
```

当把一个不具备泛型信息的对象赋值给另一个具备泛型信息的变量时，会有“[unchecked] 未经检查的转换”的编译警告，称为 **类型转换**

```java
// 类型转换：编译时仅仅提示“未经转换的异常”
List<String> stringList=list;
// 运行时产生 ClassCastException
String str=stringList.get(0);
// 类型转换：编译时仅仅提示“未经转换的异常”，运行时没有异常
List<Integer> integerList=list;
Integer integer=integerList.get(0);
```

### 泛型和数组

如果 Foo 是 Bar 的子类，那么 `Foo[]` 也是 `Bar[]` 的子类，但`List<Foo>` 不是 `List<Bar>` 的子类

- 数组是类型不安全的：即使编译时正常，运行时也可能出现 `ArrayStoreException`

    ```java
    // Integer 是 Number 的子类，Integer[] 也是 Number[] 的子类，编译通过
    Number[] numbers = new Integer[5];
    // numbers 元素的编译时类型是 Number,运行时类型是 Integer
    // 因此可以将 double 类型的 0.5 赋值给 numbers[0], 编译通过，但在运行时会产生 ArrayStoreException
    numbers[0] = 0.5;
    ```

- 泛型是类型安全的：如果编译时没有`unchecked`警告，运行时就不会有 `ClassCastException`

    ```java
    // Integer 是 Number 的子类，List<Integer> 不是 List<Number> 的子类，编译不通过
    List<Number> numbers = new ArrayList<Integer>();
    ```