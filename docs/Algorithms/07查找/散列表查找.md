# 散列表\(哈希表\)查找

**散列技术：**在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f\(key\)

**散列函数：**散列技术中的"对应关系"f称为散列函数，又称**哈希\(Hash\)函数**

**散列表：**采用散列技术将记录存储在一块**连续的**存储空间中，该存储空间称为散列表，又称**哈希表\(Hash Table\)**

**散列表查找步骤**

1. 存储时，通过散列函数计算记录的散列地址并存储该记录。
2. 查找时，通过同样的散列函数直接计算得到记录的散列地址

散列技术即是存储方法，也是查找方法。

采用散列技术存储的记录之间不存在任何逻辑关系，因此主要是面向查找的存储结构

散列技术最适合的求解问题是查找与给定值相等的记录

散列表不适合一个关键字对应多个记录的情况，也不适合范围查找

**冲突：**关键字key1!=key2，但散列值f\(key1\)==f\(key2\)。key1和key2称为这个散列函数的**同义词\(synonym\)**

## 散列函数的构造方法

**散列函数的参考原则**

* 计算简单：散列函数的计算时间不应该超过其他查找技术与关键字比较的时间
* 散列地址分布均匀：保证存储空间的有效利用，并减少处理冲突耗费的时间

**散列函数的构造方法**

* **直接定址法：**取关键字的某个线性函数值为散列地址f\(key\)=a\*key+b
  * 简单、均匀、无冲突，需要事先知道关键字的分布情况，适合查找表较小且连续的情况
* **数字分析法：抽取**关键字的一部分来计算散列地址。
  * 适合处理关键字位数比较大的情况，若事先知道关键字的分布且关键字的若干位分布较均匀
* **平方取中法：**取其平方的中间n位数作为散列地址，适合不知道关键字分布且关键字位数不大的情况
* **折叠法：**将关键字从左到右分割成位数相等的几部分，叠加求和，并按散列表表长取后n位作为散列地址
  * 适合事先不知道关键字分布，关键字位数较多的情况
* **除留余数法：**f\(key\)=key mod p\(p&lt;=m\)
  * 可将key折叠、平方后再取模
  * p通常是小于等于表长的最小质数或不包含小于20质因子的合数
* **随机数法：**f\(key\)=random\(key\)，适合构造长度不等的关键字的散列函数

字符串等各种符号最终都可以转换成数字对待

**构造散列函数的参考因素**

1. 计算散列地址所需的时间
2. 关键字的长度
3. 散列表的大小
4. 关键字的分布情况
5. 记录查找的频率

## 处理散列冲突的方法

**开放定址法：**一旦产生冲突，就去寻找下一个空的散列地址；只要散列表足够大，总能找到空的散列地址

* **线性探测法：**f\(key\)=\(f\(key\)+d\) mod m    \(d=1,2,……,m-1\)
* **二次探测法：**f\(key\)=\(f\(key\)+d\) mod m    \(d=1^2,-1^2,2^2,……-q^2,q&lt;=m/2\)
* **随机探测法：**f\(key\)=\(f\(key\)+d\) mod m    \(d是随机数列中的一个数）
* **堆积：**本来不是同义词的关键字却需要争夺一个地址的情况

**再散列函数法：**当产生冲突时，换用另外的散列函数来计算其散列地址

* 能够使关键字不产生聚集，但增加了计算的时间

**链地址法：**将所有关键字为同义词的记录存储在一个单链表中，该单链表称为**同义词子表**，在散列表中只存储所有同义词子表的头指针

* 对于会造成大量冲突的散列函数来说，解决了找不到地址的问题
* 查找时需要遍历单链表带来较大的时间损耗

**公共溢出区法：**将所有有冲突的关键字存储在一张独立的溢出表中

* 查找时，对给定值通过散列函数计算出散列地址后，先与基本表进行对比，若相等则查找成功，否则到溢出表中进行顺序查找
* 相对基本表而言，有冲突的数据较少时，查找性能非常高



