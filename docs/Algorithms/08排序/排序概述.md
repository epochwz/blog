---
author: s3kj-mwy
email: s3kj.mwy@gmail.com

date: 2017-11-24 13:37:44
title: 排序算法概述
tags: [Algorithms,Sort,intro]
categories:
- Algorithms
- Sort
---

### 排序的定义
> __排序算法(Sorting Algorithm)__是一种能根据指定的关键字将一串记录按照特定排序方式(递增/递减)进行排列的算法。

- [ ] 多个关键字的排序总能转换成单个关键字的排序

### 排序的稳定性
> 待排序记录中存在多个关键字相等的记录，经过排序后其相对次序不改变，则称该算法是稳定的，反之称为不稳定的。

### 内排序
> 在排序的整个过程中，待排序的所有记录全部被放置在内存中

__内排序算法的性能影响因素__
- __时间性能：__高效率的内排序算法应该尽可能的减少(比较和移动)记录的次数。
    - [ ] 记录的移动操作往往可以通过改变记录的存储方式来避免。
- __辅助空间：__算法需要的辅助存储空间=待排序记录占用的存储空间+执行算法所需要的其他存储空间
- __算法的复杂度：__算法本身的复杂程度(非时间复杂度)

__内排序算法的分类：__插入排序、交换排序、选择排序、归并排序

### 外排序
> 由于待排序记录数量太多，无法同时放置在内存中，整个排序过程需要在内外存之多次交换数据


### 分治法
> 意为"分而治之"。将一个复杂的原问题分解为若干个__规模更小、结构一致(相似)__的子问题，直至最后的子问题能够被简单的求解，然后递归的解决这些子问题，从而解决原问题

__实现__
1. __分解：__将原问题分解为若干个规模较小、相对独立、与原问题形式相同的子问题
2. __解决：__若子问题易于解决时则直接求解，否则继续递归的解决子问题
3. __合并：__将子问题的解合并成原问题的解

__分治法的实现前提__
- 原问题的规模缩小到一定的程度能够很容易的解决
- 原问题能够被分解成若干个规模较小的相同子问题
- 子问题的解最终能够合并成原问题的解(涉及分治法能否实现，若不满足则应该考虑__贪心算法和动态规划__)
- 子问题是相互独立的,即子问题之间不包含公共的子问题(涉及分治法效率，若子问题不独立则分治法需要重复的解决公共子问题。此时__动态规划__更合适)


__示例算法：__快速排序、归并排序、折半查找、快速傅里叶变换、汉诺塔

