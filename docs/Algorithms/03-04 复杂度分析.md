# 复杂度分析

## 为什么需要复杂度分析

数据结构和算法研究的是如何让代码运行更快、更省空间的问题，因此需要一个考量代码执行效率的方法。

通常，我们可以通过直接运行代码来统计、监控算法执行的时间和占用的内存，这种评估算法执行效率的方法称为“**事后统计法**”

这种分析方法存在明显的缺陷

- 测试环境影响测试结果：不同硬件的处理速度不一样，直接影响测试结果
- 测试数据影响测试结果：测试数据规模大小、是否有序等特性都会影响测试结果，比如针对小规模数据排序，插入排序可能比快速排序还要快

因此，我们需要一个不使用具体测试数据来测试，就可以粗略估计算法执行效率的方法，这就是**复杂度分析**方法，包括了 **时间复杂度**和 **空间复杂度**

## 什么是时间复杂度

先来看一段代码

```java
1   int sum=0;
2   for(int i=0;i<n;i++){
3       sum+=i;
4   }
```

在这段代码中，每一行代码的执行过程包括 **读数据**-**运算**-**写数据**, 尽管执行时间可能不太一样，但都可以当作一个单位时间 **unit_time**

在这段代码中，第1行代码执行了1次，第2,3行代码都执行了n次,那么总的执行时间就是T(n)=(1+n+n)*`unit_time`=(2n+1)*`unit_time`

- 第1行代码执行了1次，记作 T1=1*`unit_time`
- 第2,3行代码都执行了n次，记作 T2=n*`unit_time`+n*`unit_time`=2n*`unit_time`
- 这段代码总共执行时间就是 T(n)=T1+T2=(2n+1)*`unit_time`

因此，一段程序的执行时间 T(n) 与代码执行的次数 f(n) 成正比，记作`T(n)=O(f(n))`, 这就是**大 O 时间复杂度表示法**，用来表示代码执行时间随着数据规模增长的变化趋势，也称为 **渐进时间复杂度**

- T(n) 是代码总的执行时间
- f(n) 是代码总的执行次数
- O 表示 T(n) 与 f(n) 成正比
- f(n)=2n^2+3n+1 -> T(n)=f(n)*`unit_time`=O(f(n))=O(2n^2+3n+1)=O(n^2)

如何分析一段代码的时间复杂度

- 只关注循环执行次数最多的一段代码
- 加法法则：总复杂度等于量级最大的那段代码的复杂度：`T1(n)=O(f(n)),T2(n)=O(g(n));T(n)=T1(n)+T2(n)=max(O(f(n)),O(g(n)))=O(max(f(n),g(n)))`
- 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积：`T1(n)=O(f(n)),T2(n)=O(g(n));T(n)=T1(n)*T2(n)=O(f(n)*g(n))`

常见时间复杂度

1. 多项式量级
   - 常量阶 O(1)
   - 对数阶 O(logn)
   - 线性阶 O(n)
   - 线性对数阶 O(nlogn)
   - 平方阶 O(n^2)
   - 立方阶 O(n^3)
   - k 次方阶 O(n^m)
2. 非多项式量级
   - 指数阶 O(m^n)
   - 阶乘阶 O(n!)

| 量级  | 大 O 表示法         | 备注                                      |
| --- | ------------- | --------------------------------------- |
| 常量阶 | O(1)          | 代码执行时间不随数据规模 n 的增长而增长，O(100000) 也记为 O(1)    |
| 对数阶 | O(logn)       | 底数可以忽略`log3 n=log3 2 * log2 n=C*log2 n` |
|     | O(m+n)/O(m*n) | 时间复杂度由两个数据规模决定                          |

空间复杂度：算法的存储空间与数据规模之间的增长关系

## 其他时间复杂度分析方法

如果代码在不同情况下有不同的时间复杂度，那就会存在**最好 / 最坏时间复杂度**，两者都是极端情况计算出来的时间复杂度，不具备一般性，因此需要使用 **平均时间复杂度**

考虑了不同情况的概率概率计算加权平均值的分析方法得到的结果，称为**平均时间复杂度**

利用摊还分析方法得到的结果，称为**均摊时间复杂度**

均摊时间复杂度是一种特殊的平均时间复杂度，只是使用的分析方法不一样而已。

满足以下条件时使用均摊时间复杂度

1. 代码在不同情况下的时间复杂度出现量级的差别，即低级别复杂度和高级别复杂度
2. 低级别复杂度和高级别复杂度的出现具有时序规律。
3. 低级别复杂度和高级别复杂度的出现概率相差较大。
   - 低级别 >> 高级别，摊还后自然是低级别复杂度
   - 高级别 >> 低级别，摊还后自然是高级别复杂度（通常这种情况都需要所谓的摊还分析了)

递归代码的时间复杂度分析较为复杂，可以参考 [拜托，面试别再问我时间复杂度了 !!!][] 这篇文章，递归部分的复杂度分析写的很不错。

[拜托，面试别再问我时间复杂度了 !!!]:https://mp.weixin.qq.com/s/yfzrFYn0Dogy0HkN5XAS0Q