# 树的存储结构

## 双亲表示法

* 使用一维数组存储树的结点
* **结点：数据域**存储数据信息，**双亲域**存储双亲结点的地址\[数组下标\]
* 特点：容易寻找结点的双亲结点，但寻找结点的孩子则必须遍历整棵树
* 优化
  * 增加**长子域**\[记录最左孩子的地址\]：解决了0-2个孩子的寻找问题
  * 增加**右兄弟域**\[记录右兄弟的地址\]：解决兄弟的寻找问题
* C语言描述

  ```
    // 树的最大结点数
    #define MAX_TREE_SIZE 100
    // 树结点的数据类型
    typedef int ElemType;

    // 结点
    typedef struct Node
    {
        // 数据域：存储结点的数据信息
        ElemType data;
        // 指针域：存储双亲结点的地址
        // 根结点没有双亲，约定其指针域指向-1
        int parent;
    }Node;

    // 树
    typedef struct
    {
        // 结点数组
        Node nodes[MAX_TREE_SIZE];
        // 根的数组下标
        int root;
        // 结点数
        int count;
    };
  ```

## 孩子表示法

**多重链表表示法：**每个结点设多个指针域,存储其子树的根结点

* 结点指针域的个数等于树的度：浪费空间,只适用于各结点度相差极小的树
* 结点指针域的个数按需分配\[等于各结点的度\]：数据域、度数域\[存储指针域的个数\]、指针域
  * 克服了空间浪费，但各个结点的链表结构不同，且需要维护结点的度的数值，带来运算上的时间损耗

**孩子表示法**

* 使用一维数组存储所有结点
* 使用多个单链表存储每个结点的所有孩子结点\[叶结点的单链表为空表\]
* 特点
  * 解决了某个结点孩子和兄弟的查找问题：查找该结点的孩子结点单链表
  * 解决了整棵树的遍历问题：遍历头结点数组
  * 难以寻找某个结点的双亲
* 优化：在孩子表示法的表头结点中增加双亲域，称为**双亲孩子表示法**
* C语言描述

  ```
  // 树的最大结点数
  #define MAX_TREE_SIZE 100
  // 树结点的数据类型
  typedef int ElemType;

  // 孩子结点
  typedef struct CNode
  {
      // 数据域：存放当前孩子结点在顺序表数组中的下标
      int child;
      // 指针域：存放下一个孩子结点的指针
      struct CNode *next;
  } *ChildPtr;

  // 表头结点
  typedef struct
  {
      // 数据域：存储结点的数据信息
      ElemType data;
      // 指针域：存放第一个孩子结点的指针
      ChildPtr firstChild;
  } TNode;

  // 树
  typedef struct
  {
      // 表头结点数组
      TNode nodes[MAX_TREE_SIZE];
      // 根结点的数组下标
      int root;
      // 结点数
      int count;
  } Tree;
  ```

## 孩子兄弟表示法

**孩子兄弟表示法：**数据域+长子域+右兄弟域

* 任意一棵树，其结点的第一个孩子若存在则唯一，其右兄弟若存在也唯一
* 特点：方便寻找某个结点的孩子结点\[通过firstChild找到长子，通过长子的rightSib找到次子，直至结束\]
* C语言描述
  ```
  typedef struct CSNode
  {
    // 数据域：数据结点的数据信息
    ElemType data;
    // 长子域：存储第一个孩子的地址
    struct CSNode *firstChild;
    // 右兄弟域：存储右兄弟的地址
    struct CSNode *rightsib;
  }
  ```



