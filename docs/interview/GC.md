# 垃圾回收机制 (GC)

Java 的 `自动内存管理机制` 作为其语言特性的王牌之一，自动化地解决了 `对象内存分配` 和 `对象内存回收` 两个问题

其主要活动区域是 Java Heap

## 垃圾判断算法

对象被判定为垃圾的标准：没有被其他对象引用

- 引用计数法：通过计算对象的引用数量来判断对象是否可以被回收
  - 实现：每个对象实例都拥有一个引用计数器，被引用则 +1, 被释放则 -1 (该引用超过生命周期(局部变量)或者被设置成新的值或者 NULL)
  - 任何引用计数是 0 的对象实例可以被当作垃圾进行回收
  - 优点：执行效率高，程序执行受影响较小
  - 缺点：无法检测出循环引用的情况，从而导致内存泄漏
- 可达性分析：通过判断对象的引用链是否可达来判断对象是否可以被回收
  - 实现：
  - 可以作为 GC ROOT 的对象
    - 虚拟机栈中引用的对象 (栈帧中的本地变量表)
    - 本地方法栈中 JNI (Native 方法) 的引用对象
    - 方法区中的常量引用的对象
    - 方法区中的静态变量引用的对象
    - 活跃线程的引用对象

## 垃圾回收算法

- 标记-清除算法 (Mark and Sweep)
  - 实现
    - 标记：从根集合进行扫描，对存活的对象进行标记
    - 清除：对堆内存从头到尾进行线性遍历，回收不可达对象占用的内存
  - 缺点
    - 碎片化：由于仅对不可达的对象进行清除，而不需要进行对象的移动，因此会产生大量不连续的内存碎片，导致在后续需要分配较大内存的对象时，不得不提前触发又一次 GC 操作
- 复制算法 (Copying)
  - 实现：将内存按一定比例分成 对象区域 和 空闲区域
    1. 对象在对象区域上创建
    2. 当对象区域内存不足时，存活的对象被复制到空闲区域
    3. 清除对象区域中的所有对象，并标记成空闲区域
  - 优点
    - 解决碎片化问题
    - 顺序分配内存，简单高效
    - 适用于对象存活率低的场景 (年轻代)
- 标记-整理算法 (Compacting)
  - 实现
    - 标记：从根集合进行扫描，对存活的对象进行标记
    - 清除：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址之后的内存全部回收
  - 特点
    - 避免内存的不连续性
    - 不用设置两块内存进行互换
    - 适用于存活率高的场景 (老年代)
- 分代收集算法 (Generational Collector)
  - 实现：将内存进行进一步划分，针对不同特点的内存区域采用不同的垃圾回收算法
  -  按照对象生命周期的不同划分区域
  - 目的：提高 JVM 垃圾回收效率
  - 分类
    - Minor GC (年轻代的回收)：复制算法
    - FULL GC (老年代的回收，通常引发年轻代的回收)：标记整理或标记清除算法


年轻代：尽可能快速的回收掉那些生命周期短的对象

- 一个 Eden 区：对象刚被创建时，会为其分配 Eden 区的内存空间 (当内存空间不足时，可能直接被分配在 Survivor 甚至是老年代)
- 两个 Survivor 区：分成 From 区和 To 区，两者随着垃圾回收的进行而互换

YOUNG:OLD=1:2
Eden:From:To=8:1:1


年轻代对象如何晋升到老年代

- 经历一定次数的 Minor GC 后依然存活的对象
- Survivor 区中存放不下的对象
- 新生成的大对象 (-XX: +PretenuerSizeThreshold)

常用的调优参数

- -XX:SurvivorRatio: Eden 和 Survivor 的比值，默认 8:1
- -XX:NewRatio 老年代和年轻代内存大小的比值，默认 2
- -XX:MaxTenuringThreshold: 对象从年轻代晋升到老年代所需要经过的 GC 次数的阈值

### 老年代

老年代：存放生命周期较长的对象

Full GC 比 Minor GC 慢 (10 倍以上)，但执行频率较低

触发 Full GC 的条件

- 老年代空间不足
- 永久代空间不足
- `CMS GC` 时出现的 `promotion failed`、`concurrent mode failure`
- Minor GC 晋升到老年代的平均大小大于老年代的剩余空间
- 程序中直接调用 `System.gc();` (建议)
- 使用 RMI 进行 RPC 或管理的 JDK 应用，默认每小时执行一次 FULL GC



`Stop the World`: JVM 由于要执行 GC 而停止了应用程序的执行，会在任何一种 GC 算法中发生

- 除了 GC 线程以外的其他线程都处于等待状态
- GC 优化通常就是指减少 `Stop the World` 发生的时间来提高程序性能，从而使系统具有高吞吐、低停顿

`Safepoint` 安全点：可达性分析过程中对象引用关系不会发生变化的点 (方法调用、循环跳转、异常跳转)

### 常见的垃圾收集器

JVM 的运行模式

- Server: 启动较慢，之后程序运行速度快 (采用重量级 JVM)
- Client: 启动较快，之后程序运行速度慢 (采用轻量级 JVM)
