# Java 内存模型

## 为什么需要 JMM

因为我们在 Java 源程序中写的各种 Lock 所实现的效果, 最后其实还是依赖于 JVM 的具体实现和 CPU 的机器指令，而不同的 JVM 实现对源程序的 “翻译” 结果可能不一样，不同的 CPU 平台的机器指令又千差万别；所以如果没有内存模型，那么程序的处理结果就会高度依赖于处理器，导致不同处理器对同一个 Java 程序可能有不同的处理结果，也就无法保证并发安全。

因此 Java 语言需要实现一个标准，使得多线程运行的结果变得可预期，这个标准就是 **Java 内存模型** (JMM,Java Memory Model)

## JMM 是什么

- JMM 是要求各个 JVM 实现需要共同遵守的一系列规范
  - 如果没有这个规范，那么程序经过不同 JVM 各自不同规则的重排序之后，可能出现程序在不同的虚拟机上运行结果不一致的情况
  - 正是有了这个规范，使得不同的 JVM 可以配合编译器、CPU 等统一遵守这个规范，从而让开发者可以更加方便的开发多线程程序
- JMM 是工具类和关键字的原理 (volatile,synchronized,Lock)
  - 如果没有这个规范，那就需要开发者自己指定什么时候使用诸如内存栅栏 (内存的拷贝和同步) 等手段，编程就会变得相当麻烦
  - 正是有了这个规范，使得我们只需要使用 Java 提供的同步工具和关键字就可以轻松地开发并发程序

## JMM 的内容

### 重排序

**重排序的定义**：编译器 或 CPU 出于优化的目的，使得代码的实际执行顺序和源文件中的书写顺序不一致的情况，这种 `乱序执行` 的现象称为 `指令重排序`

**重排序的好处**：提高程序的处理速度

**重排序的坏处**：由于只会对不存在数据依赖关系的指令进行重排序，所以重排序在单线程环境下依然可以保证执行结果的正确性，但是在多线程环境下就有可能导致执行结果不符合预期结果的情况

**发生重排序的三种情况**

- 编译器优化 (JVM/JIT)
- CPU 指令重排
- 内存 “重排序”：内存的可见性问题可能会带来类似重排序的效果
  - 内存系统内实际上并不存在重排序，但是由于内存中缓存的存在 (主内存和本地内存不一致)，会使得多线程程序出现乱序执行的情况，从而带来和重排序看上去一样的效果

### 可见性

#### 什么是可见性问题

一个线程的执行结果不能及时的被另一个线程 “看见”，从而导致另一个线程读取到的数据是过期的，这种现象称为 **可见性问题**

#### 为什么会有可见性问题

由于 CPU & RAM 之间存在多级缓存，所以可能导致其他核心读取到的数据是过期的

1. 由于高速缓存的容量比主内存小，但是速度却仅次于寄存器，因此通常会在 CPU & RAM 之间增加多个 Cache 层

   ![CPU 和 RAM 之间的多级缓存]

2. CPU 中每个核心都会将自己所需要的数据 `从主内存 (拷贝) 读入到独占缓存中`, 修改数据后也是先 `写入到独占缓存中`, 然后再 `等待刷入主内存`, 因此导致了其他核心可能读取到过期的值

> ! 多线程之间对于共享变量的可见性问题不是由于多核处理器引起的，而是由于多级缓存造成的：如果多个核心共用一个缓存，那么也不会存在内存的可见性问题

#### JMM 的抽象

Java 作为一门高级语言，屏蔽了 CPU 、寄存器、多层缓存之间的实现细节，并使用 JMM 定义了一套读写内存数据的规范，抽象出了主内存和本地内存

此处的本地内存并不是实际分配给每个线程的一块内存，而是 JMM 对寄存器、一级缓存、二级缓存的抽象

![主内存和本地内存](/docs/images/notes/java/main-ram-and-local-ram.png)

JMM 规定

- 所有的变量都存储在主内存中，同时每个线程也有自己独立的工作内存，工作内存中的变量内容是主内存的拷贝
- 线程不能直接读写主内存中的变量，只能操作自己工作内存中的变量，然后再同步到主内存中
- 主内存是多个线程共享的，但线程间不共享工作内存，如果线程间需要通信，必须借助主内存中转来完成

所有的共享变量存在主内存中，每个线程拥有自己独立的工作内存，而线程读写共享数据也是通过工作内存交换的，而这种交换无法做到实时，因此导致了可见性问题

#### Happens-Before

**什么是 Happens-Before 规则？**

Happens-Before 规则 (先行发生原则) 是 JVM 规范所承诺的一系列可以保证两个操作之间具备有序性的规则 (具备有序性的两个操作之间不存在可见性问题)

- HB 规则可以用来解决可见性问题：在时间上，如果操作 A 发生在操作 B 之前，那么操作 B 保证能够看见操作 A
- HB 规则可以用来确定两个操作的执行顺序：如果两个操作的执行顺序不能从 HB 规则中推导出来，那么这两个操作就不具备有序性

**什么不是 Happens-Before 规则？**

如果两个线程没有相互配合的机制，导致代码 X 和 Y 的执行结果并不能保证总被对方看到，那么就不具备 Happens-Before 性质

**Happens-Before 有哪些规则？**

- 程序次序规则：单个线程内，按照代码顺序，书写在前面的的操作先行发生于书写在后面的操作
  - 一段程序代码的执行在单个线程中看起来总是有序的 (虽然虚拟机可能对其进行重排序，但由于只会对不存在数据依赖性的指令进行重排序，因此其执行结果仍然与代码书写顺序所预期的结果是一致的)
  - 这个规则虽然保证了程序在单线程中执行结果的正确性，但是无法保证程序在多线程中执行结果的正确性
- 线程启动规则：线程的 start() 方法先行发生于该线程的其他所有操作 (run() 方法中的所有操作)
- 线程终止规则：线程的其他所有操作都先行发生于线程的终止 (通过 isAlive() 进行检测到线程终止 或者 join() 方法结束)
- 线程中断规则：对某线程 interrupt() 方法的调用先行发生于检测到它发生中断的代码 (`isInterrupted() == true` / `catch InterruptedException`)
  - 这条规则保证了线程的中断标记可以被正确的检测到、中断异常可以被正确的捕获到
- 对象终结规则：一个对象的初始化完成 (构造方法中的最后一条指令) 先行发生于它的 finalize() 方法的开始 (第一条指令)
- 传递规则：如果操作 A 先行发生于操作 B, 而且操作 B 先行发生于操作 C, 那么可以得出操作 A 先行发生于操作 C
- **锁操作规则**：一个 unlock 操作先行发生于后续对同一个锁的 lock 操作 (对 synchronized 同样适用)
- **volatile 变量规则**：对一个 volatile 变量的写操作 (以及在这之前的所有操作) 先行发生于后续对这个变量的读操作
- 工具类
  - 线程安全的容器的 get 等读操作一定能看到之前发生的 put 等写操作
  - 线程池
  - CountDownLatch
  - Semaphore
  - Future
  - CyclicBarrier

#### volatile

volatile 是一种比 synchronized & Lock 更轻量的同步机制，因为使用 volatile 并不会产生上下文切换等开销很大的操作

- 如果一个变量被 volatile 修饰，则 JVM 就知道了它可能会被并发修改，从而履行其职责 (禁止重排序、保证可见性)
- volatile 并不能做到 synchronized 那样的原子保护，因此仅能在很有限的场景下发挥作用

**作用**

- 保证可见性：读一个 volatile 变量之前，需要先使相应的本地缓存失效，这样就必须从主内存中读取最新值；写一个 volatile 属性立即刷入到主内存
- 禁止重排序

**适用场景**

- 纯赋值操作：如果一个共享变量至始至终只是被各个线程进行纯粹的赋值操作 (不依赖共享变量先前的状态) ，而没有其他操作，那么就可以用 volatile 来代替 synchronized 或者 原子变量，因为纯粹的赋值操作本身已经具备原子性 ，volatile 又保证了可见性，所以足以保证线程安全
- 作为内存同步的触发器：实现变量的实时刷新，是一种轻量级的同步机制

**性质**

- volatile 共享变量一旦被某个线程修改了，其他线程保证可以立即看到 (得到) 修改后的值
- volatile 的读写操作都是无锁的
- volatile 不能代替 synchronized, 因为它没有提供原子性和互斥性
- volatile 只能作用于属性，禁止编译器对其进行重排序
- volatile 保证了可见性，任何线程对其进行修改，将立马对其他线程可见。volatile 属性不会被线程缓存，始终从主存中读取
- volatile 提供了 happens-before 保证：一个线程对 volatile 变量 v 的写入操作 happens-before 其他所有线程后续对 v 的读操作
- volatile 可以使得 long & double 的赋值操作是原子的

### 原子性

**什么是原子性？**

如果一系列操作是不可分割的，一旦开始执行，就不会被打断 (要么全部执行成功，要么全部不执行，绝不会出现执行一半的情况)，则称这一系列操作具备原子性

Java 中具备原子性的操作

- 除了 long & double 之外的基本类型的赋值操作
- 所有引用 (reference) 的赋值操作
- `java.concurrent.Atomic.*` 包中所有类的原子操作

long & double 的原子性问题

- long & double 的操作在 32 位的 JVM 上不具备原子性，而在 64 位的 JVM 则具备原子性
- 在实际开发中，不必做额外处理，因为商用虚拟机基本都可以保证其原子性

原子操作+原子操作!=原子操作

## 有序性

JMM 允许编译器和处理器对指令进行重排序，这种重排序不会影响单线程程序的执行，但会影响多线程并发执行的正确性

**保证有序性的措施**

- 使用 volatile 禁止重排序
- 使用 synchronized / Lock 保证每个时刻只有一个线程可以执行同步代码，相当于让线程顺序执行同步代码，自然保证了有序性
- JMM 承诺的先天有序性：先行发生原则 (Happens-Before), 如果两个操作的执行次序不能从 Happens-Before 原则中推导出来，虚拟机就可以随意对他们进行重排序

[CPU 和 RAM 之间的多级缓存]: /docs/images/notes/java/multi-cache-between-cpu-ram.png
