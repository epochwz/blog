# 三大特征

## 封装

### 封装的定义

**定义**：隐藏类的状态数据和行为特征，使外部程序无法直接访问类的内部信息，只能通过该类提供的访问途径来实现对该类内部信息的操作和访问，称之为 **封装 (Encapsulation)**

Java 中的封装是通过 `包机制` 和 `访问权限修饰符` 一起实现的

### 包机制

**包机制**：提供类的多层命名空间，从而解决类的源文件管理、命名冲突问题，同时提供了控制类的访问权限的基础

- `package` 定义类所在的包，必须放在源文件第一行
- `import` 导入其他包中的类，`import static` 导入其他包中的类的静态成员，必须放在 `package` 定义之后，`class` 定义之前

| 语法                                         | 作用                                                        |
|:---------------------------------------------|:------------------------------------------------------------|
| `package p1.p2.p3;`                          | 定义类所在的包                                               |
| `import p1.p2.ClassName;`                    | 导入指定包下的某个类                                         |
| `import p1.p2.*;`                            | 导入指定包下的所有类，**但子包 `p1.p2.p3` 下的类并不会被导入** |
| `import static p1.p2.className.staticMember` | 导入指定包下的某个类的类成员                                  |
| `import static p1.p2.className.*`            | 导入指定包下的某个类的所有类成员                              |
| `javac -d className.java`                    | 编译的同时生成与包结构相对应的目录                            |
| `java packageName.className`                 | 执行带包结构的类                                             |

**不同包的类之间相互调用的两种方式**

1. 使用类的全名 `p1.p2.className`
2. 使用 `import 和 import static` 导入其他包的类或类成员，避免使用类的全名，从而简化代码

   - `java.lang` 下的类已经被系统默认导入，因此无需使用类的全名，也无需显式使用 `import` 导入

### 访问权限修饰符

**访问权限修饰符**：用于控制一个类及其成员是否可以被其他类访问，从而实现类的封装

| 访问修饰符 | 本类 | 本包 | 子类 | 其他 |
|:----------|:-----|:-----|:----|:-----|
| private   | ✔   |      |     |      |
| default   | ✔   | ✔    |     |      |
| protected | ✔   | ✔    | ✔   |      |
| public    | ✔   | ✔    | ✔   | ✔   |

## 继承

### 继承的定义

**定义**：如果使用已存在的类 A 作为基础建立新的类 B，则称这两个类之间存在 **继承 (Inheritance)** 关系，满足 `B is a A` 的关系

- 使用关键字 `extends` 实现继承，Java 只支持单继承，即每个类只能有一个直接父类
- 子类可以增加新的特征和行为，也可以使用父类的功能，但不能选择性的继承父类
- 子类可以访问父类的公有成员，父类无法访问子类的特有成员
- 子类可以获得父类全部的成员变量和方法，但不能获得父类的构造器

### 方法重写

**方法重写的规则**

- 发生在子类和父类之间
- 方法名相同、参数列表相同
- 访问权限大于等于父类
- 返回值类型范围小于等于父类（相同或继承于父类的返回值类型）
- 抛出的异常类型小于等于父类
- 覆盖方法和被覆盖方法必须是同类型方法『同为类方法或同为实例方法』

**方法重载 和 方法重写 的区别**

| 方法重载                             | 方法重写                                  |
|:------------------------------------|:------------------------------------------|
| 发生在同一个类中                     | 发生在子类和父类之间                       |
| 方法名相同，参数列表不同              | 方法名、参数列表相同                       |
| 与方法返回值、修饰符、抛出异常类型无关 | 存在访问权限、返回值类型、抛出异常类型的限制 |

**子类无法重写父类的 private 方法**

- 子类访问不到父类的 private 方法（包括静态方法），所以也就无法重写。
- 子类若定义了相同的方法名，形参列表，相同返回值类型的方法，也只是重新定义了一个新方法。
- 如果使用父类声明引用变量，则最终调用的还是父类的方法

### super

- 子类可以通过 `super` 调用父类构造器、实例成员
- 若子类重写了父类实例方法，则无法直接调用父类被覆盖的方法，但可以通过 `super` 进行调用
- 若子类定义了和父类同名的变量，则子类会屏蔽父类变量
  - 可以通过 `super` 调用父类的实例变量
  - 可以通过 `类名` 直接调用父类的类变量
  - **系统查找变量的顺序**：方法中的局部变量 -> 类中的成员变量 -> 直接父类中的成员变量 -> 上溯至 `java.lang.Object` -> 外部类中的成员变量 -> 外部类直接父类中的成员变量 -> 上溯至 `java.lang.Object` -> 编译出错

### 继承和组合

**组合**：将旧类对象作为新类的成员变量组合进来，以实现新类的功能。

- 通常使用 private 修饰被组合的旧类，从而隐藏旧类信息，只暴露新类的方法

**继承和组合**：继承是一种 `is-a` 的关系，而组合是 `has-a` 的关系，两者都是实现类复用的重要方式。

- 继承：破坏封装性，子类可以直接访问和修改父类的状态数据（实例变量) 和行为特征（方法)
- 组合：封装性更好，但不具备多态性

**使用继承的原则**

- 保证子类是一种特殊的父类，满足 `is-a` 的关系
- 子类需要增加自己独有的属性或方法『新增方法或重写父类方法』
- 如果只是出于类复用的目的，则应该用组合来实现

## 多态

**定义**：当引用变量的 `编译时类型` 和 `运行时类型` 不一致时，就可能出现 *相同类型的引用变量调用同一个方法时呈现出不同（子类）的行为特征 的情况*，这种情况称为 **多态 (Polymorphism)**；

- **编译时类型**：声明变量时使用的数据类型
- **运行时类型**：实际赋给变量的对象的数据类型

**多态的必要条件**

- 满足继承关系，父类引用指向子类对象
- 满足接口实现关系，接口引用指向实现类对象

**多态的分类**

- 编译时多态：方法重载
- 运行时多态：Java 运行时系统根据调用该方法的实例的运行时类型来决定应该选择调用哪个类的方法

**多态的其他规则**

- 引用变量在编译阶段只能调用其编译时类型所拥有的成员，而不能调用其运行时类型所拥有的成员
- 引用变量在运行阶段调用公有的实例方法时，系统会试图调用其运行时类型重写过的方法
- 引用变量在运行阶段调用类成员、实例 变量、私有实例方法时，系统仍然调用其编译时类型所持有的
