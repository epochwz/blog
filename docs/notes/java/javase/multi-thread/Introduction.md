# 并发编程基础入门

好处：提高程序运行效率

坏处

- 带来线程安全问题
- 可能带来性能问题

## 实现线程

实现线程只有两种方式：`实现 Runnable 接口` 或者 `继承 Thread 类`

## 启动线程

使用 `start()` 启动线程而不是 `run()`

- 在当前线程中执行 `T.start()` 的含义：当前线程请求 JVM 执行新线程 T
  - 因此 `T.start()` 这行代码仍然是由当前线程执行的，此时线程 T 尚未启动 (至于线程 T 究竟何时运行，则只能由线程调度器来决定)
- 线程 T 被执行前的准备工作
  - 先让线程 T 处于就绪状态：获取到除了 CPU 资源以外的其他资源 (设置上下文、栈、线程状态、PC 计数器等)
  - 然后才能被 JVM 调度到执行状态，等待获取 CPU 资源
  - 然后才能真正进入运行状态，执行 run 方法中的代码
- 线程启动方法本身就是线程安全的 `synchronized void start()`
- 由 JVM 创建的 main 方法线程和 system 组线程，并不会通过 start 来启动

## 停止线程

正确停止线程的基本原则是使用 `interrupt` 进行中断通知，而不是强制停止

**线程只有在两种情况下会停止**

- 正常执行完毕
- 执行过程中发生未捕获的异常

**使用中断停止线程的典型场景**

- 线程正常运行期间
- 线程处于阻塞期间
- 线程每次迭代中都进行阻塞

**线程响应中断的两种最佳实践**

- 传递中断 (优先选择)：优先选择抛出异常，以便于该异常可以传递到线程的顶层调用方法 (run)
  - 由于 run 方法无法向上抛出异常，因此必须选择合适的方式处理该异常，从而增强了代码的健壮性，避免了线程中的异常被 “吞掉” 的危险
- 恢复中断 (备用选择)：如果不想或者无法抛出异常，就得调用 `Thread.currentThread().interrupt()` 来恢复线程的中断标记，以便上层调用者仍然能够检查到线程是否已经处于中断状态
- 屏蔽中断 (错误选择)

**能够响应中断异常的方法列表**

- `wait / sleep / join`
- `java.util.concurrent.BlockingQueue.take / put`
- `java.util.concurrent.locks.Lock.lockInterruptibly()`
- `java.util.concurrent.CountDownLatch.await()`
- `java.util.concurrent.CyclicBarrier.await()`
- `java.util.concurrent.Exchanger.exchange()`
- `java.nio.channels.InterruptibleChannel 相关方法`
- `java.nio.channels.Selector 相关方法`

**停止线程的几种典型错误方法**

- 使用 `stop / suspend / resume`: JDK 已弃用的方法
- 使用 `volatile 设置 boolean 标记`: 无法处理线程长时间阻塞的情况

**如何处理不可中断的阻塞**

- 没有通用的处理方案，特定场景特定分析
- 比如尽量使用工具类提供的可响应中断的方法 `ReentrantLock.interruptibly()`
- 比如关闭套接字使线程立即返回

## 生命周期

**线程状态**

| 线程状态       | 状态说明 | 备注                                                   |
|:--------------|:--------|:-------------------------------------------------------|
| NEW           | 新创建   | 创建之后，启动之前                                      |
| RUNNABLE      | 可运行   | 启动之后，终止之前：未运行或运行中 (未阻塞)              |
| BLOCKED       | 被阻塞   | 尝试进入 synchronized 代码块/方法时等待 monitor 锁的状态 |
|               |         | 或者在调用 wait 之后重新进入 synchronized 等待锁时的状态  |
| WAITING       | 等待     | wait/join/park                                        |
| TIMED_WAITING | 计时等待 | wait/join/parkUntil/parkNanos/sleep                    |
| TERMINATED    | 已终止   | 执行完毕 / 意外终止                                     |

**阻塞状态**：习惯上，将 `BLOCKED、WAITING、TIMED_WAITING` 三种状态都称作阻塞状态

**↓↓↓ 线程状态转换示意图 ↓↓↓**

![ThreadLifeCycle](/docs/images/notes/java/ThreadLifeCycle.png)

## 常用方法

### 方法概览

| 类         | 方法                  | 作用                      |
|:-----------|:----------------------|:-------------------------|
| **Thread** | currentThread         | 获取当前正在执行线程的引用 |
|            | start/run             | 启动线程                  |
|            | interrupt             | 中断线程                  |
|            | sleep                 | 线程休眠                  |
|            | join                  | 等待其他线程执行完毕       |
|            | yield                 | 放弃已经获取到的 CPU 资源  |
| `已废弃`   | stop/suspend/resume   | 停止/挂起/恢复线程         |
| **Object** | wait/notify/notifyAll | 让线程暂时休息或唤醒       |

### wait/notify/notifyAll

**作用**：让一个线程暂时休息，等待条件成熟时再由其他线程将其唤醒，然后继续执行

1. 调用某个对象的 wait 方法可以使当前线程进入 `阻塞阶段`

   直到发生以下 4 种情况之一时，线程才会被唤醒

   - 另一个线程调用了这个对象的 notify 方法，且刚好被唤醒的是本线程
   - 另一个线程调用了这个对象的 notifyAll 方法
   - 另一个线程调用了本线程的 interrupt 方法
   - 过了 wait(long timeout) 指定的超时时间 (如果调用时传入零或者不传参则表示 `永久等待`)

2. 调用某个对象的 notify/notifyAll 方法可以使调用了该对象的 wait 方法的线程进入 `唤醒阶段`
3. 调用某个线程的 interrupt 方法可以使该线程 `遇到中断`

**性质**

- wait 可以让线程进入 `WAITING` 状态，直到超时或者被唤醒之后再继续执行
- 调用了 wait 的线程在等待期间不会占用 CPU 资源，而且会释放持有的对象锁
- 必须先获取到对象锁 (monitor)，才能执行其 wait/notify/notifyAll 方法
- notify 只能随机唤醒一个 wait 线程，notifyAll 可以唤醒全部 wait 线程
- wait/notify/notifyAll 都是 `final native` 修饰的

**其他**

- 注意同时持有多个锁的情况下，要按顺序正确的释放锁，否则容易导致死锁
- 由于 wait/notify 是相对底层的方法，所以 Java 封装了具备类似功能的 Condition

### sleep

**作用**：sleep 可以让线程进入 `TIMED_WAITING` 状态，直到规定的时间后再执行

**性质**：线程在休眠期间不会占用 CPU 资源，但不释放锁 (synchronized / lock)

**中断响应**：休眠期间如果被中断，会抛出异常并清除中断状态

### join

**作用**：让一个线程等待另一个线程执行完毕

- 解释：因为某个线程加入了当前线程，所以当前线程需要等待这个线程执行完毕之后，再继续执行自己的逻辑

**原理**：join 方法实际上是调用了 Thread 类实例自身的 wait 方法，而当线程的 run 方法执行完毕时，JVM 会自动执行该线程实例的 notify 方法，从而唤醒执行了 join (wait) 的线程

**中断响应**： 应该是当前线程 (`执行 xx.join() 的线程`) 进行中断处理

### yield

**作用**：让出当前线程的 CPU 资源，但线程仍然处于 `RUNNABLE` 状态，意味着有可能紧接着马上就又被调度到了

**缺陷**：JVM 不保证遵循 yield 规则 (不同 JVM 有不同的实现：比如当前 CPU 资源不紧张时，那么调用 yield 也不会释放 CPU 资源)

**性质**：`yield & sleep` 的区别在于线程是否随时可以再次被调度

## 重要属性

### 属性概览

| 属性                     | 作用                                                |
|:-------------------------|:---------------------------------------------------|
| 编号 (id)                | 用于标识不同的线程 (不能修改，从 1 开始不断自增)      |
| 名称 (name)              | 用于在开发、调试、运行过程中区分线程，定义问题         |
| 是否是守护线程 (isDaemon) | true=守护线程，false=用户线程                       |
| 优先级 (Priority)        | 告诉线程调度器，用户希望哪些线程多运行，哪些线程少运行 |

### 守护线程

**定义**：专门用于给用户线程提供服务的后台线程，成为 **守护线程**

**性质**

- 当所有用户线程都执行完毕时，守护线程也会随之结束
- 线程类型默认继承自父线程 (守护线程创建的新线程就是守护线程，用户线程创建的新线程就是用户线程)
- 线程类型可以通过 `setDaemon()` 进行设置
- JVM 启动的线程除了主线程是用户线程外，其余都是守护线程

**区别**

- 用户线程是执行业务的，守护线程是提供服务的
- 守护线程和用户线程的本质区别在于它们是否能够阻止 JVM 的退出

### 优先级

Java 线程有 10 个优先级，默认优先级是 5，子线程的优先级默认继承父线程

程序设计不应该依赖于优先级

- 因为线程调度高度依赖于操作系统，而不同操作系统的优先级实现是不一样的，因此线程的优先级是不可靠的
- 优先级可能被操作系统更改 (Windows 优先级推进器会越过优先级，优先为频繁尝试运行的线程分配 CPU 时间片)

## 异常处理

**为什么需要全局处理线程的未捕获异常**

- 主线程可以轻松的发现异常，子线程却不行
  - 主线程发生未捕获异常时，程序会直接被终止并打印异常信息，所以可以很方便的查看日志，定位问题
  - 子线程发生未捕获异常时，程序 (主线程) 并不会因此而停止，因此子线程的异常信息可能被掩盖，不易察觉
- 无法使用传统的方式在主线程中捕获并处理子线程的异常：`try/catch` 只能捕获当前线程所产生的异常
- 不全局处理子线程中的异常，可能造成严重后果：子线程将会直接终止，并且难以察觉，无人知晓 (全局处理后则可以采取补救措施，比如重启线程，告警通知，提高系统健壮性)
- 避免异常堆栈信息暴露到前端，用户体验不友好、系统安全没保障

**如何处理线程的未捕获异常 `UncaughtException`**

1. 手动在每个线程的 run 方法中 try/catch
2. 使用 `UncaughtExceptionHandler` 进行全局异常处理
   - 给程序统一设置
   - 给线程单独设置
   - 给线程池设置

**多线程异常处理器的调用策略**

1. 如果当前线程所在的 线程组 存在 父线程组，则调用其异常处理器 (父线程组的调用策略依然遵循这三个步骤)
2. 如果程序设置了 (所有) 线程的默认异常处理器，则调用之
3. 否则直接打印线程的异常信息

## 线程安全

**权威的定义**

> 当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的
>
> 《Java Concurrency In Practice》-- Brian Goetz

**通俗的解释**

> - 即使是在多线程环境下，也可以像单线程环境一样使用某个对象，而不需要做任何额外的处理，就可以得到正确的结果，那么便可以认为这个对象是线程安全的
> - 反之，如果在多线程环境下使用这个对象时还需要考虑线程在运行时的调度和交替 (比如 get 时不能 set), 或者需要进行额外的同步操作 (比如 synchronized 关键字)，那么这个对象就是线程不安全的

**实现线程安全的代价**

- 运行速度：所有方法都实现线程安全，将会降低运行速度 (退化成串行)
- 设计成本：增大代码开发的难度和工作量
- 因此如果能够预知不用于多线程环境的类，就不需要设计成线程安全的

**典型的线程安全问题**

- 运行结果错误
- 活跃性问题：死锁、活锁、饥饿
- 对象发布和初始化时的逸出问题
  - 发布逸出：将一个类发布到了不该发布的地方
    - 发布：使得一个类可以在本类以外的地方使用的操作 (使用 public 修饰类、使用 return 返回类实例、将类作为方法参数 等操作)
    - 比如：通过方法返回一个 private 对象 (private 本意是不让外部访问)
  - 初始化逸出：实例尚未完成初始化 (构造函数没完全执行完毕)，就把对象提供给外界
    - 在构造函数中未初始化完毕就 this 赋值
    - 隐式逸出：比如 注册监听事件
    - 在构造函数中启动新线程
  - 解决逸出
    - 使用 对象副本 (发布逸出)
    - 使用 工厂模式 (初始化逸出)

**常见的线程安全隐患**

- 访问共享的变量或资源 (对象属性、静态变量、共享缓存、数据库)
- 所有依赖时序的操作，即使每一步操作都是线程安全的，依然可能存在并发问题
  - 一个线程读取了一个共享数据，并在此基础上更新这个数据 `read-modify-write`
  - 一个线程读取了一个共享数据，并在此基础上决定下个操作 `check-then-act`
- 修改存在捆绑关系的数据时
- 使用没有声明线程安全的类

## 性能问题

**为什么多线程会带来性能问题**

- **调度**
  - 线程切换：当进行线程的切换时，需要保存和恢复线程上下文 (挂起当前线程，保存线程状态，恢复下个线程)
  - 缓存失效：线程切换会导致 CPU 缓存失效
  - 抢锁、IO 等情况容易导致密集的上下文切换
- **协作**
  - 内存同步：为了数据的正确性，同步手段往往会禁止编译器优化，使得 CPU 缓存失效

**上下文切换**

上下文切换可以认为是内核 (操作系统核心) 在 CPU 上对于进程 (包括线程) 进行以下的活动

1. 挂起一个进程，将这个进程在 CPU 中的状态 (上下文) 存储在内存中的某处
2. 在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复
3. 跳转到程序计数器所指向的位置 (跳转到进程被中断时的代码行)，以恢复该进程

