# 流程控制和运算符

## 流程控制

**顺序结构**：程序从上到下执行每条语句，中间无任何判断和跳转

**分支结构**：根据条件选择性的执行某段代码

- `if...elseif...else`：判断条件是一个布尔值
  - 注意：使用时不能忽略 `elseif` 自带的隐含条件，应该优先处理范围更小的情况
- `switch`：判断条件是 `byte、short、int、char、Byte、Short、Integer、Character、String、enum` 类型的变量或字面值
  - 分支条件表达式的值是上述数据类型的变量或字面值以及枚举类的枚举值

**循环结构**：根据循环条件重复执行某段代码

- 循环定义
  - `while`
  - `do...while`
  - `for`
  - `foreach`
- 循环控制
  - `break`：跳出循环体并完全结束当前循环（若紧跟标签名，则可以跳出外层循环)
  - `continue`：跳出循环体并立即执行下一次循环（若紧跟标签名，则可以跳出外层循环并立即执行下一次外层循环)
  - `return`：结束一个方法，自然也能结束当前循环

## 运算符

**运算符**: Java 源程序中的特殊符号，用于进行数据的运算、赋值和比较等操作

```java
算术运算符  +、-、*、/、%
赋值运算符  =
复合运算符  +=、-=、*=、/=、%=、++、--
关系运算符  >、<、>=、<=、==、!=
逻辑运算符  &&、&、||、|、!、^
条件运算符  ?:
位操作运算符 &、|、^、<<、>>、>>>
类型运算符
    instanceof  判断实例与类 / 接口之间是否具有继承 / 实现关系
    (type)      进行强制类型转换
```

### 算术运算符

**算术运算符**：主要用于数学计算

```java
+   加法运算、连接字符串
-   减法运算、求负运算
*   乘法运算
/   除法运算
    如果两个操作数都是整数，则计算结果是整数『截断取整』，且除数不能是 0
    如果两个操作数至少有一个浮点数，则计算结果是浮点数，且允许除数为 0『自动转换成 0.0』，结果为±无穷大
    0/0.0 除以任何非 0 数值，结果都是 0/0.0 (0/x -> 0 , 0.0/x -> 0.0)
%   求余运算
    如果两个操作数都是整数，则计算结果是整数『截断取整』，且除数不能是 0
    如果两个操作数至少有一个浮点数，则计算结果是浮点数，且允许除数为 0『自动转换成 0.0』，结果为非数 NaN
    0/0.0 对任何非 0 数值求余，结果都是 0/0.0 (0%x -> 0 , 0.0%x -> 0.0)
```

### 赋值运算符

**赋值运算符**：用于将 一个字面值 / 变量 赋值给 另一个变量

```java
=   赋值运算符
    运算规则：从右向左计算
```

### 复合运算符

**复合运算符**：结合了算术运算符和赋值运算符的功能，进行计算后直接将值赋值给变量

```java
+=、-=、*=、/=、%=  先进行相应运算，再赋值给左侧变量

++  自增运算
    ++i 先自增，再参与运算
    i++ 先参与运算，再自增
--  自减运算
    --i 先自减，再参与运算
    i-- 先参与运算，再自减
```

### 关系运算符

**关系运算符**：用于判断两个操作数的大小，计算结果是一个布尔值

```java
>   大于
<   小于
>=  大于等于
<=  小于等于
!=  不等于，规则同 ==
==  等于
    如果操作数都是数值类型，即使数据类型不同，只要值相等就返回 true
    如果操作数都是引用类型，仅当两个操作数的数据类型具有继承 / 接口关系时才可以比较，仅当两个引用变量指向同一个对象时才返回 true
equals
    Object 类的默认方法，用于自定义两个对象相等的标准
    Object 类默认只是比较两个对象的地址是否相等，作用与 == 相同
    String 类和包装类已经重写了 equals() 方法：只要两个字符串所包含的字符序列相同，则返回 true
```

### 逻辑运算符

**逻辑运算符**：用于操作数之间的逻辑判断，操作数都是布尔型，计算结果也是一个布尔值

```java
&&  短路与，左边表达式为 false 时直接返回，不计算右边表达式
&   不短路与
||  短路或，左边表达式为 true 时直接返回，不计算右边表达式
|   不短路或
^   异或，两边表达式不同时返回 true，相同时返回 false
!   取反
```

### 条件运算符

**条件运算符**：用于代替 `if...else` 进行简单的逻辑判断，计算结果可以是任意数据类型

```java
(expression) ? value-for-true : value-for-false;
```

### 位运算符

**位运算符**：用于对整数进行位操作，操作数只能是整型数值

```java
5&9    按位与：两位同时为 1 返回 1
5|9    按位或：只要有一位为 1 即可返回 1
5^9    按位异或：两位相同时返回 0，不同返回 1
5<<2   左移运算符：左边截断，右边空出的位补 0
-5>>2  右移运算符：左边补充符号位的值，右边截断
-5>>>2 无符号右移运算符：左边总是以 0 补充
```

移位运算规则

- 低于 int 类型时，自动转换为 int 类型后再移位
- int 类型，a>>b，当 b>32 时，实际移位位数是 b%32 `eg:a>>1 等价于 a>>65`
- long 类型，a>>b，当 b>64 时，实际移位位数是 b%64
- 左移相当于乘以 2 的 n 次方，右移相当于除以 2 的 n 次方
- 移位运算只是产生一个新的运算结果，不会改变操作数本身

### 类型运算符

#### (type) var

- 基本类型之间的转换只能在数值类型之间进行『整数型、浮点型、字符型，不包括布尔型』
- 引用类型之间的转换只能在具有继承 / 实现关系的两个类型之间进行
  - 如果把父类实例转换成子类类型，则该实例的运行时类型必须是子类实例『即编译时类型为父类类型，运行时类型为子类类型』，否则将引发 `ClassCastException`

#### instanceof

`引用类型变量 instanceof 类 / 接口` 用于判断前面的对象是否是后面的类 / 接口的实例，从而判断是否可以进行安全的强制类型转换

- 左边变量的编译时类型必须与右边的类 / 接口具有继承 / 实现关系，才可以使用 `instanceof` 进行比较
- `instanceof` 使用左边变量的运行时类型判断该变量是否为右边类 / 接口的实例
- **示例**

    ```java
    // 定义 hello 变量，编译时类型是 Object，运行时类型是 String
    Object hello = "Hello";
    
    // 相同类型 / 存在继承关系，可以进行 instanceof 运算。
    System.out.println("字符串是否是 Object 类的实例："+ (hello instanceof Object)); // true
    System.out.println("字符串是否是 String 类的实例："+ (hello instanceof String)); // true

    // Math 与 Object 类存在继承关系，可以进行 instanceof 运算
    System.out.println("字符串是否是 Math 类的实例："+ (hello instanceof Math)); // false（运行时类型不一致）

    // String 实现了 Comparable 接口，所以返回 true。
    System.out.println("字符串是否是 Comparable 接口的实例："+ (hello instanceof Comparable));
    
    // String 类与 Math 类没有继承关系，所以下面代码编译无法通过
    String str = "Hello";
    System.out.println("字符串是否是 Math 类的实例："+ (str instanceof Math));
    ```

### 运算符优先级

![运算符优先级]

[运算符优先级]: /docs/images/notes/java/operator-priority.png
